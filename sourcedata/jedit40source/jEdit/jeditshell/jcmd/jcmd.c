/* jcmd.c - jEdit buffer properties:                              */
/* :mode=c:tabSize=4:indentSize=4:noTabs=false:indentOnTab=false: */
/* :indentOnEnter=true:syntax=true:maxLineLen=80:                 */

/*
 * jcmd.c - A command interpreter for use with the Java's platform
 * Runtime.exec() on the Windows family of operating systems, designed
 * to prevent the display of console windows when executing console-based
 * programs; specifically designed to be used with jEdit's Console plugin
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the use and distribution of
 * the resulting library or executable file shall be subject to the General
 * Public License. This condition does not require a licensee of this software
 * to distribute any proprietary software (including header files and libraries)
 * that is licensed under terms prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the jEdit program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: jcmd.c,v 1.9 2001/09/16 22:59:30 jgellene Exp $
 */

/*
 * To compile this file use the following command line:
 *
 * cl /nologo /ML /W4 /O2 /Ox /D "WIN32" /D "NDEBUG" /D "_MBCS" jcmd.c \
 * /link user32.lib advapi32.lib /subsystem:windows /version:2.0 \
 * /entry:mainCRTStartup
 */

/* suppress warning on automatic inline expansion */
#pragma warning( disable : 4711)

#include <windows.h>
#include <stdlib.h>
#include "jcmd.h"


int main(int argc, char** argv)
{
	PJCMD_EXEC_DATA pData;
	HANDLE hStdError = GetStdHandle(STD_ERROR_HANDLE);
	int nTestReturn, nReturn;
	if(argc < 2)
	{
		WriteMessage("jcmd error: no command given.", hStdError);
		return 1;
	}
	pData = LocalAlloc(LPTR, sizeof(JCMD_EXEC_DATA));
	if(!InitJcmdData(pData, argc, argv))
	{
		WriteMessage("jcmd error: command is not valid.", hStdError);
		ClearJcmdData(pData);
		LocalFree(pData);
		return 1;
	}

	/*
	 * The file and path parameters can have the following combinations:
	 * (1) Full path, full file name - execute SearchCommand once
	 * (2) Full path, no extension - execute SearchCommand once for each
	 *	   extension in pathext variable
	 * (3) No path, full file name - execute SearchCommand for each directory
	 *	   in path search using full path name
	 * (4) No path, no extension - for each directory in search path,
	 *     execute SearchCommand for each extension in pathext variable
	 */

	if(pData->hasPath)
	{
		nTestReturn = TestSinglePath(pData);
	}
	else
	{
		nTestReturn = TestMultiPath(pData);
	}
	if(nTestReturn == 0)
	{
		WriteMessage("Could not find command.", hStdError);
		nReturn = 1;
	}
	else
	{
		nReturn = pData->nReturnCode;
	}
	ClearJcmdData(pData);
	LocalFree(pData);
	return nReturn;
}

/*
 * InitJcmdData()
 * Initializes application data using command line parameters
 * Returns 1 if initialization successful and 0 if first parameter
 * (path string) is empty or if no filename is found in path
 */
int InitJcmdData(PJCMD_EXEC_DATA pData, int argc, char **argv)
{
	// main() tests for argc < 2
	char *pPath, *pFileName;
	int index;
	pPath = argv[1];
	if(pData == 0 || pPath == 0 || *pPath == 0)
		return 0;
	/* Check for a path separator */
	pData->hasPath = strchr(pPath, '\\') ? 1 : 0;
	if(pData->hasPath)
	{
		GetFullPathName(pPath, MAX_PATH, pData->execPath, &pFileName);
		if(pFileName == 0 || *pFileName == 0)
			return 0;
		strcpy(pData->execName, pFileName);
		// this will truncate pData->execPath
		memset(pFileName, 0, strlen(pFileName));
	}
	else
	{
		strcpy(pData->execName, pPath);
	}
	/* Check file name for extension */
	pData->hasExt = strchr(pData->execName, '.') ? 1 : 0;
	if(pData->hasExt)
		pData->isExec = IsExec(pPath);

	/*
	 * Collect the rest of the command line as a single parameter.
	 * The first character will be whitespace because later it will
	 * be joined to a command string.
	 */
	if(argc > 2)
	{
		for(index = 2; index < argc; ++index)
		{
			/* Quote any command line item containing spaces */
			char *pSpace = strchr(argv[index], ' ');
			pData->szParams[strlen(pData->szParams)] = ' ';
			if(pSpace != 0)
				strcat(pData->szParams, "\"");
			strcat(pData->szParams, argv[index]);
			if(pSpace != 0)
				strcat(pData->szParams, "\"");
		}
	}

	/* Load the search extensions from the environment or use default. */
	if(!pData->hasExt)
	{
		if(!GetEnvironmentVariable("PATHEXT", pData->szPathExt, MAX_PATH))
		{
			strcpy(pData->szPathExt, ".CMD;.BAT;.COM;.EXE");
		}
	}

	/*  If there is no file path, get the path environment variable. */
	if(!pData->hasPath)
	{
		char test;
		DWORD dwPathLength = GetEnvironmentVariable("PATH", &test, 1);
		DWORD dwPathBufLength = ((dwPathLength / MAX_PATH) + 1) * MAX_PATH;
		pData->pPaths = LocalAlloc(LPTR, dwPathBufLength);
		if(dwPathLength - 1 != GetEnvironmentVariable("PATH", pData->pPaths, dwPathBufLength))
		{
			LocalFree(pData->pPaths);
			pData->pPaths = 0;
		}
	}

	return 1;
}

/*
 * ClearJcmdData()
 * This performs cleanup of application data object before application exits;
 * it must be called if pPaths data member is created.
 */
void ClearJcmdData(PJCMD_EXEC_DATA pData)
{
	LocalFree(pData->pPaths);
}

/*
 * LaunchCommand()
 * This is the heart of the command interpreter. Once a file path is
 * found and tied to an existing file association, this function creates
 * a process using the fully interpreted command. The main window of the
 * process is hidden. The function then tests the top-level windows created
 * by the main thread of the new process to see if a console window has
 * been created. If no console window has been created, the application
 * being executed has a Windows GUI (which is now hidden). In that case,
 * LaunchCommand() closes the main window and restarts the process with
 * the main window displayed normally. Finally, the function waits for the
 * new process to exit and return the exit code back to jcmd's
 * calling function and eventually to its main routine.
 */
int LaunchCommand(PJCMD_EXEC_DATA pData)
{
	STARTUPINFO *psi = &(pData->si);
	PROCESS_INFORMATION *ppi = &(pData->pi);
	PTESTCONSOLE ptc = &(pData->tc);
	DWORD dwResult;
	if(*(pData->szParams) != 0)
	{
		strcat(pData->szCmd, " ");
		strcat(pData->szCmd, pData->szParams);
	}
	// initialize process startup information
    psi->cb = sizeof(STARTUPINFO);
    psi->dwFillAttribute = 0;
    psi->dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    psi->wShowWindow = SW_HIDE;
    //psi->hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    psi->hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    psi->hStdError = GetStdHandle(STD_ERROR_HANDLE);

	if(!CreateProcess(NULL, pData->szCmd, NULL, NULL,
		TRUE, 0, NULL, NULL, psi, ppi))
	{
		WriteProcessError(psi->hStdError);
		pData->nReturnCode = (DWORD)-1;
		return 1;
	}
	/* Make sure the process completed its startup */
	WaitForInputIdle(ppi->hProcess, 1000);
	/*
	 * Iterate over top-level windows of the thread
	 * and look for a console.
	 */
	EnumThreadWindows(ppi->dwThreadId, FindConsoleWindow, (LPARAM)ptc);
	if(!FoundConsole(ptc))
	{
		/*
		 * This is a windows program.  We will terminate it
		 * as politely as possible and restart it with a normal
		 * instead of a hidden main window.
		 */
		EnumThreadWindows(ppi->dwThreadId, CloseThreadWindow, 0);
		/* If we couldn't kill the window, we kill the process. */
		dwResult = WaitForSingleObject(ppi->hThread, 0);
		if(dwResult == WAIT_TIMEOUT || dwResult == WAIT_ABANDONED)
			TerminateProcess(ppi->hProcess, 1);
	    psi->wShowWindow = SW_SHOW;
		psi->dwFlags = STARTF_USESHOWWINDOW;
		/* A loop here is not necessary. */
		if(!CreateProcess(NULL, pData->szCmd, NULL, NULL,
			TRUE, 0, NULL, NULL, psi, ppi))
		{
			WriteProcessError(psi->hStdError);
			pData->nReturnCode = (DWORD)-1;
			return 1;
		}
	}
	/* Start thread to wait on input */
	pData->hInputThread = CreateThread(0, 0, &InputThreadProc,
		(LPVOID)pData, 0, &(pData->nInputThreadID));
	if(pData->hInputThread == 0)
	{
		WriteProcessError(GetStdHandle(STD_OUTPUT_HANDLE));
	}
	else
	{
		WriteMessage("Thread created.\n", GetStdHandle(STD_OUTPUT_HANDLE));
	}


	/* Now we wait for the process to end to get the return code. */
	Sleep(2000);
    switch(WaitForSingleObject(ppi->hProcess,INFINITE))
	{
    	case WAIT_FAILED:
    	case WAIT_ABANDONED:
    	case WAIT_TIMEOUT:
        	break;
    	default:
        	GetExitCodeProcess(ppi->hProcess, &(pData->nReturnCode));
    }
	return 1;
}

/*
 * SearchCommand()
 * This function executes a single search for a file
 * based upon the information containined in the data object
 * and an optional file extensions.  If the file is found, this
 * function directs substitution of file associations and
 * environment variables, then calls LaunchCommand() to execute
 * the fully interpreted command
 */
int SearchCommand(PJCMD_EXEC_DATA pData, char* pExt)
{
	char *pFilePart;
	if(SearchPath(pData->szTestPath, pData->execName, pExt, 1024,
		pData->szCmd, &pFilePart))
	{
		strcpy(pData->szScratch, pData->szCmd);
		if(!IsExec(pFilePart))
		{
			MakeFileAssoc(pData->szCmd, pData->szScratch);
		}
		else
		{
			ExpandEnvironmentStrings(pData->szScratch, pData->szCmd, 1024);
		}
		return LaunchCommand(pData);
	}
	return 0;
}

/*
 * TestSingleExt()
 * This wrapper function is used for a single file search when
 * the file's extension is specified.
 */
int TestSingleExt(PJCMD_EXEC_DATA pData)
{
	return SearchCommand(pData, 0);
}

/*
 * TestMultiExt()
 * This function iterates through all of the default
 * file extensions, calling SearchCommand() on the
 * command data object with each extension.  It is used
 * with a specific file path when a file extension must be
 * supplied.
 */
int TestMultiExt(PJCMD_EXEC_DATA pData)
{
	int nReturn = 0;
	char *pExt = ExtractExt(pData->szTestExt, pData->szPathExt);
	while(pExt != 0 && *pExt != 0 && *(pData->szTestExt) != 0)
	{
		nReturn = SearchCommand(pData, pData->szTestExt);
		if(nReturn == 1) break;
		pExt = ExtractExt(pData->szTestExt, pExt);
	}
	return nReturn;
}

/*
 * TestSinglePath()
 * This function is called by the main routine to test the data
 * representing a single full path for the existence of a file.
 * It delegates actual file name testing to either TestSingleExt()
 * or TestMultiExt(), depending on whether a given full path ends
 * with a file extension.
 */
int TestSinglePath(PJCMD_EXEC_DATA pData)
{
	PJCMD_TEST_FUNC testFunc = pData->hasExt ?
		&TestSingleExt : &TestMultiExt;
	strcpy(pData->szTestPath, pData->execPath);
	return testFunc(pData);
}

/*
 * TestMultiPath()
 * This function is called by the main routine to test the data
 * representing a file name where no path is given.  The function
 * iterates through various possibilities for a full path.  The
 * order of the iteration emulates the file search protocol of the
 * standard command interpreter, including the system path. (One
 * exception in this version is that the 16-bit Windows directory,
 * usually named C:\WINNT\System, is not searched in Windows NT and
 * Windows 2000. For each test path, the function calls TestSingleExt()
 * or TestMultiExt(), depending on whether a given full path ends with
 * a file extension.
 */
int TestMultiPath(PJCMD_EXEC_DATA pData)
{
	DWORD dwLength;
	int nReturn;
	char *pPath;
	PJCMD_TEST_FUNC testFunc = pData->hasExt ?
		&TestSingleExt : &TestMultiExt;
	/* order of search */
	/* (1) Current directory */
	dwLength = GetCurrentDirectory(MAX_PATH, pData->szTestPath);
	nReturn = testFunc(pData);
	if(nReturn == 1) return 1;
	/* (2) Windows system directory */
	dwLength = GetSystemDirectory(pData->szTestPath, MAX_PATH);
	nReturn = testFunc(pData);
	if(nReturn == 1) return 1;
	/* (3) System path, one-by-one */
	pPath = ExtractExt(pData->szTestPath, pData->pPaths);
	while(pPath != 0 && *pPath != 0 && *(pData->szTestPath) != 0)
	{
		nReturn = testFunc(pData);
		if(nReturn == 1) break;
		pPath = ExtractExt(pData->szTestPath, pPath);
	}
	return nReturn;
}


/*
 * FindConsoleWindow()
 * This callback function is called on each top-level window in
 * the main thread of a process created by LaunchCommand(). It
 * looks for one of the two window class names used by versions
 * of Windows for console windows. If a console window is found,
 * the TESTCONSOLE structure to which the lparam parameter points
 * receives the handle of the console window. The count element
 * of the structure is incremented for the window being examined.
 */
int CALLBACK FindConsoleWindow(HWND hwnd, LPARAM lparam)
{
	char			window_class[32];
	PTESTCONSOLE	ptest = (PTESTCONSOLE)lparam;

	++ptest->nCount;
	GetClassName(hwnd, window_class, sizeof (window_class));
	if(strcmp(window_class, "ConsoleWindowClass") == 0
		|| strcmp(window_class, "tty") == 0)
	{
		ptest->hwnd = hwnd;
		/*
		 * We found what we were looking for; returning 0
		 * will end the iteration in EnumThreadWindows
		 */
		return 0;
	}
	return 1;
}


/*
 * CloseThreadWindow()
 * This callback function examines the window to determine
 * whether it is a candidate for closing.  A candidate must be
 * a frame window having the following characteristics:
 * (1) a top-level window;
 * (2) without an owner;
 * (3) lacking the WS_POPUP style.
 * To close the window, the function first sends it a WM_CLOSE
 * message. If that doesn't work, it sends a system command message
 * to close (similar to pressing Alt-F4).  If that doesn't work,
 * the method reports failure and the main routine will
 * terminate the window's process.
 */
int CALLBACK CloseThreadWindow(HWND hwnd, LPARAM lparam)
{
	HWND hwndParent, hwndPopup;
	/* unused */
	lparam;

	if(!IsWindow(hwnd))
		return 1;
	while((hwndParent = GetParent(hwnd)) != 0)
	{
		/*
		 * In the unlikely event that a popup child window
		 * was immediately activated, we will first close
		 * the popup
		 */
		hwndPopup = GetLastActivePopup(hwndParent);
		if(hwndPopup != hwndParent)
		{
			SendMessage(hwndPopup, WM_QUIT, 0, 0);
		}
		hwnd = hwndParent;
	}
	if(GetWindow(hwnd, GW_OWNER) == 0)
	{
		DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
		if(dwStyle != 0 && (dwStyle & WS_POPUP) == 0)
		{
			SendMessage(hwnd, WM_CLOSE, 0, 0);
			if(IsWindow(hwnd))
				SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0);
			/* Whether it worked or not, we are done
			 * iterating through windows.
			 */
			return 0;
		}
	}
	return 1;
}

/*
 * FoundConsole()
 * We have a console if:
 * (1) we could not find any windows (because the console
 * window is built-in under some versions of Windows); or
 * (2) we found a window from one of the two console window
 * classes used by windows - FindConsole() put that window's
 * handle into the TESTCONSOLE structure.
 */
int FoundConsole(PTESTCONSOLE pt)
{
	return pt->nCount == 0 || pt->hwnd != 0;
}

/* IsExec()
 * Returns 1 if string ends with an executable extension
 * and 0 otherwise.
 */
int IsExec(char* szFileName)
{
	char *pDot;
	if(szFileName == 0 || (pDot = strrchr(szFileName, '.')) == 0)
		return 0;
	if(stricmp(pDot, ".exe") == 0) return 1;
	if(stricmp(pDot, ".bat") == 0) return 1;
	if(stricmp(pDot, ".cmd") == 0) return 1;
	if(stricmp(pDot, ".com") == 0) return 1;
	return 0;
}


/*
 * ExtractExt()
 * This customized parsing routine extracts a single file extension
 * from a string of extensions separated by semicolons. The return
 * value points to the location to start the next extraction.
 */
char* ExtractExt(/* [out] */ char* pPathExt, /* [in] */char* pExt)
{
	int extLen, extLenNoQuote;
	if(*pExt == ';') ++pExt;
	if(*pExt == '\"') ++pExt;
	extLen = strcspn(pExt, ";");
	extLenNoQuote = extLen;
	if(extLen != 0 && *(pExt + extLen - 1) == '\"')
		--extLenNoQuote;
	*pPathExt = 0;
	strncat(pPathExt, pExt, extLenNoQuote);
	return pExt + extLen;
}

/*
 * MakeFileAssoc()
 * This function finds the command associated with the input
 * file's extension (if one exists) and interprets the resulting
 * command string to insert the input file and perform substitution
 * of environment variables.  If no association can be found, the
 * output file is a copy of the input file.
 */
void MakeFileAssoc(/* [out] */ char* szDest, /* [in] */ char* szSource)
{
	char *pExt, szKey[1024], szVerb[32];
	const int nKeyLength = 1024;
	const int nVerbLength = 32;
	int nSuccess = 0;
	HKEY hKey = 0;
	DWORD dwLength = nKeyLength;

	pExt = strrchr(szSource, '\\');
	pExt = (pExt == 0) ? 0 : strrchr(pExt, '.');

	if(pExt != 0)
	{
		nSuccess = RegOpenKeyEx(HKEY_CLASSES_ROOT, pExt, 0, KEY_READ, &hKey);
		if(nSuccess == ERROR_SUCCESS)
		{
			nSuccess = RegQueryValueEx(hKey, 0, 0, 0,
				(unsigned char*)szKey, &dwLength);
			if(nSuccess == ERROR_SUCCESS && dwLength != 0)
			{
				RegCloseKey(hKey);
				hKey = 0;
				strcat(szKey, "\\shell");
				nSuccess = RegOpenKeyEx(HKEY_CLASSES_ROOT,
					szKey, 0, KEY_READ, &hKey);
				if(nSuccess == ERROR_SUCCESS)
				{
					dwLength = nVerbLength;
					nSuccess = RegQueryValueEx(hKey, 0, 0, 0,
						(unsigned char*)szVerb, &dwLength);
					if(nSuccess != ERROR_SUCCESS || dwLength == 0)
					{
						strcpy(szVerb, "open");
					}
					RegCloseKey(hKey);
					hKey = 0;
					strcat(szKey, "\\");
					strcat(szKey, szVerb);
					strcat(szKey, "\\command");
					nSuccess = RegOpenKeyEx(HKEY_CLASSES_ROOT,
						szKey, 0, KEY_READ, &hKey);
					if(nSuccess == ERROR_SUCCESS)
					{
						dwLength = nKeyLength;
						nSuccess = RegQueryValueEx(hKey, 0, 0, 0,
							(unsigned char*)szKey, &dwLength);
					}
				}
			}
		}
		if(hKey != 0)
		{
			RegCloseKey(hKey);
		}
		if(nSuccess == ERROR_SUCCESS && dwLength != 0)
		{
			char szExpanded[1024];
			memset(szExpanded, 0, 1024);
			ExpandEnvironmentStrings(szKey, szExpanded, 1024);

			pExt = strstr(szExpanded, "%1");
			if(pExt != 0)
			{
				dwLength = pExt - szExpanded;
				strncpy(szDest, szExpanded, dwLength);
				*(szDest + dwLength) = 0;
				strcat(szDest, szSource);
				if(strlen(pExt) > 0)
					strcat(szDest, (pExt + 2));
			}
		}
	}
	if(pExt == 0 || nSuccess != ERROR_SUCCESS)
	{
		strcpy(szDest, szSource);
	}
}

/*
 * WriteProcessError()
 * This function writes a system error message to
 * the stream referenced by the handle.
 */
void WriteProcessError(HANDLE handle)
{
	char szMsg[256];
	LPVOID lpMsgBuf;
	strcpy(szMsg, "Could not create jcmd process: ");
	FormatMessageA(
    	FORMAT_MESSAGE_ALLOCATE_BUFFER |
    	FORMAT_MESSAGE_FROM_SYSTEM |
    	FORMAT_MESSAGE_IGNORE_INSERTS,
    	NULL,
    	GetLastError(),
    	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
    	(LPSTR) &lpMsgBuf,
    	0,
   		NULL
	);
	strcat(szMsg, (LPCSTR)lpMsgBuf);
	LocalFree(lpMsgBuf);
	WriteMessage(szMsg, handle);
}

/*
 * WriteMessage()
 * This methods writes a string to a resource represented by the
 * handle parameter.  It is used in jcmd to write data to the
 * standard error stream.
 */
void WriteMessage(char* szMsg, HANDLE handle)
{
	DWORD dwLength;
	WriteFile(handle, szMsg, strlen(szMsg), &dwLength, 0);
}

/* ImputThreadProc()
 * Waits for and reads input from calling process
 */
DWORD WINAPI InputThreadProc(LPVOID lp)
{
	const char CTRL_C = (char)3;
	PJCMD_EXEC_DATA pData = (PJCMD_EXEC_DATA)lp;
	HANDLE hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	HANDLE hStdOutput = pData->si.hStdOutput;
	char ch = 0;
	DWORD dwBytesRead;
	int nSuccess;
	WriteMessage("InputThreadProc started...\n", hStdOutput);
	while(1)
	{
		nSuccess = ReadFile(hStdInput, (LPVOID)&ch, 1, &dwBytesRead, 0);
		if(nSuccess && ch == CTRL_C)
		{
			WriteMessage("Ctrl-C received.\n", hStdOutput);
			/* terminate child process */
			TerminateProcess(pData->pi.hProcess, 1);
			break;
		}
	}
	return 1;
}


/* end jcmd2.c */

