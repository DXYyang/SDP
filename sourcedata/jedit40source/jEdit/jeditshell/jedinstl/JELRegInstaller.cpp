/*
 * JELRegInstaller.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: JELRegInstaller.cpp,v 1.14 2002/02/19 03:33:44 jgellene Exp $
 */

#include "stdafx.h"
#include <string.h>
#include "InstallData.h"
#include "StringPtr.h"
#include "InstallerLog.h"
#include "JELRegInstaller.h"
#include <assert.h>

#include <stdlib.h> // for itoa in debug

/* Implementation of JELRegistryInstaller */

JELRegistryInstaller::JELRegistryInstaller(const InstallData *ptrData,
										   Installer *ptrOwner)
	: pData(ptrData), pOwner(ptrOwner) {}

JELRegistryInstaller::~JELRegistryInstaller() {}

HRESULT JELRegistryInstaller::Install()
{
	InstallerLog::Log(Message, "Commencing installation of registry entires. . . .\n");
	HRESULT hr;

	// register proxy/stub DLL
	CString strPath(pData->strInstallDir);
	strPath += _T("\\jeservps.dll");
	if(FAILED(hr = RegisterDLL(strPath, TRUE)))
		return hr;

	// registration of unlaunch for "Add/Remove Programs" applet
	// other data added by COM server
	RegisterUninstall();

	// register COM server
	strPath = pData->strInstallDir;
	strPath += _T("\\jeditsrv.exe");
	if(FAILED(hr = RegisterEXE(strPath)))
	{
		// TODO: try to restore former setting
		return hr;
	}

	// register the context menu handler
	strPath = pData->strInstallDir;
	strPath += pData->bUsingTempFileName ?
		_T("\\jeshlstb.dl_") : _T("\\jeshlstb.dll");
	if(FAILED(hr = RegisterDLL(strPath, TRUE)))
		return hr;

	// if we are still using the temporary file name, fix the
	// registration entry so it will be correct after rebooting
	if(pData->bUsingTempFileName)
	{
		if(FAILED(hr = CorrectTempCtxReg()))
		{
			InstallerLog::Log(Debug,
				"Registration of context menu handler could not be corrected.\n");
			return hr;
		}
	}

	RegisterPrimaryVersion();
	RegisterCmdLineParameters();
	return hr;
}

HRESULT JELRegistryInstaller::RegisterDLL(LPCTSTR szPath, BOOL bRegister)
{
	if(bRegister)
	{
		InstallerLog::Log(Message, "Registering %s. . .\n", szPath);
	}
	FARPROC proc = 0;
	HRESULT hr;
	LPCTSTR szProc = bRegister ? _T("DllRegisterServer") :
		_T("DllUnregisterServer");
	HMODULE hModule = ::LoadLibrary(szPath);
	if(hModule == 0)
	{
		InstallerLog::Log(Error, "Could not load library in %s\n.",
			szPath);
		return E_FAIL;
	}
	proc = GetProcAddress(hModule, szProc);
	if(proc == 0)
	{
		InstallerLog::Log(Error, "Could not get address for %s in %s\n.",
			szProc, szPath);
		hr = E_FAIL;
	}
	else
	{
		hr = (proc)();
		if(hr != S_OK)
		{
			if(bRegister)
			{
				InstallerLog::Log(Error, "Registration failed; error code 0x%08x.\n");
			}
			hr = E_FAIL;
		}
		else
		{
			InstallerLog::Log(Message, "Registration succeeded.\n");
		}
	}
	if(hModule != 0)
		FreeLibrary(hModule);
	return hr;
}

HRESULT JELRegistryInstaller::RegisterEXE(LPCTSTR szPath, BOOL bRegister)
{
	if(bRegister)
	{
		InstallerLog::Log(Message, "Registering %s. . .\n", szPath);
	}
	CString strCmdLine(szPath);
	strCmdLine += (bRegister ? _T(" /RegServer") : _T(" /UnregServer"));
	CStringBuf<> bufCmdLine(strCmdLine);
	STARTUPINFO si;
	::ZeroMemory(&si, sizeof(si));
	PROCESS_INFORMATION pi;
	BOOL bReturn =  CreateProcess(0, bufCmdLine, 0, 0, 0, 0, 0, 0, &si, &pi);
	if(!bReturn)
	{
		if(bRegister)
			InstallerLog::Log(Error, "Registration failed.\n");
		DWORD swError = GetLastError();
	}
	else
	{
		if(bRegister)
			InstallerLog::Log(Message, "Registration succeeded.\n");
	}
	return bReturn ? S_OK : E_FAIL;
}

HRESULT JELRegistryInstaller::CorrectTempCtxReg()
{
	HKEY hKey = 0;
	CString strClassKeyPath((LPCSTR)IDS_REG_CTX_SERVER_KEY);
	int nResult = RegOpenKeyEx(HKEY_CLASSES_ROOT,
		strClassKeyPath, 0, KEY_SET_VALUE, &hKey);
	if(nResult == ERROR_SUCCESS)
	{
		nResult = RegSetValueEx(hKey, 0, 0, REG_SZ,
			(const LPBYTE)(LPCTSTR)pData->strInstallFinalPath,
			InstallData::GetBufferByteLen(pData->strInstallFinalPath));
	}
	RegCloseKey(hKey);
	return nResult == ERROR_SUCCESS ? S_OK : E_FAIL;
}


HRESULT JELRegistryInstaller::RegisterUninstall()
{
	InstallerLog::Log(Message, "Registering uninstall data for Add/Remove programs...\n");
	HKEY hKey;
	CString strUninstallKey((LPCSTR)IDS_REG_UNINSTALL_KEY);
	strUninstallKey += pData->strInstallVersion;
	::OutputDebugString(strUninstallKey);
	int nResult = RegCreateKeyEx(HKEY_CURRENT_USER,
		strUninstallKey, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_WRITE, 0, &hKey, 0);
	if(nResult == ERROR_SUCCESS)
	{
		InstallerLog::Log(Debug, "Found uninstall key\n");
		CString strUninstall(pData->strInstallDir);
		strUninstall += "\\unlaunch.exe";
		nResult = RegSetValueEx(hKey, "UninstallString", 0, REG_SZ,
			(const LPBYTE)(LPCTSTR)strUninstall,
			InstallData::GetBufferByteLen(strUninstall));
		InstallerLog::Log(Debug, "UninstallString %s.\n",
			nResult == ERROR_SUCCESS ? "OK" : "error");
		CString strInstall(pData->strInstallDir);
		strInstall += "\\jedit.exe /i ";
		strInstall += pData->strJavaHome;
		nResult = RegSetValueEx(hKey, "InstallPath", 0, REG_SZ,
			(const LPBYTE)(LPCTSTR)strInstall,
			InstallData::GetBufferByteLen(strInstall));
		InstallerLog::Log(Debug, "Install Path %s.\n",
			nResult == ERROR_SUCCESS ? "OK" : "error");
		CString strDisplayIcon(pData->strInstallDir);
		strDisplayIcon += "\\jedit.exe, 0";
		nResult = RegSetValueEx(hKey, "DisplayIcon", 0, REG_SZ,
			(const LPBYTE)(LPCTSTR)strDisplayIcon,
			InstallData::GetBufferByteLen(strDisplayIcon));
		InstallerLog::Log(Debug, "Display Icon %s.\n",
			nResult == ERROR_SUCCESS ? "OK" : "error");
	}
	else
		InstallerLog::Log(Error, "Could not find uninstall registry key.\n");
	RegCloseKey(hKey);
	InstallerLog::Log(Message, "Uninstall registration %s.\n",
		nResult == ERROR_SUCCESS ? "succeeded" : "failed");
	return (nResult == ERROR_SUCCESS ? S_OK : E_FAIL);
}

HRESULT JELRegistryInstaller::RegisterPrimaryVersion()
{
	// register scripting object and designated context menu handler
	// get default value for GUID
	// get ProgID under GUID
	// default value becomes default value for class 'JEdit.JEditLauncher'
	// CLSID is GUID
	// CurVer is ProgID

	CString strClassKey(_T("CLSID\\"));
	const CString& strGUID = pData->strInstallGUID;
	strClassKey += strGUID;
	CString strClassName;
	CString strCurVer;
	CString strCurVerDir;
	HKEY hKey;
	int nResult;
	int nCounter = 20;
	// waiting for possible registration of new server in separate thread
	do
	{
		Sleep(50);
		nResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strClassKey, 0,
			KEY_READ | KEY_QUERY_VALUE, &hKey);
	} while(nResult != ERROR_SUCCESS && --nCounter != 0);
	if(nResult == ERROR_SUCCESS)
	{
		CStringBuf<>pClassBuf(strClassName);
		DWORD dwLength = pClassBuf.Size();
		RegQueryValueEx(hKey, 0, 0, 0, (LPBYTE)pClassBuf, &dwLength);
		HKEY hSubkey;
		nResult = RegOpenKeyEx(hKey, _T("ProgID"), 0, KEY_READ, &hSubkey);
		if(nResult == ERROR_SUCCESS)
		{
			CStringBuf<>pCurVerBuf(strCurVer);
			dwLength = pCurVerBuf.Size();
			RegQueryValueEx(hSubkey, 0, 0, 0, (LPBYTE)pCurVerBuf, &dwLength);
		}
		RegCloseKey(hSubkey);
		nResult = RegOpenKeyEx(hKey, _T("LocalServer32"), 0, KEY_READ, &hSubkey);
		if(nResult == ERROR_SUCCESS)
		{
			CStringBuf<>pCurVerDirBuf(strCurVerDir);
			dwLength = pCurVerDirBuf.Size();
			RegQueryValueEx(hSubkey, 0, 0, 0, (LPBYTE)pCurVerDirBuf, &dwLength);
			InstallData::ShortenToDirectory(pCurVerDirBuf);
		}
		RegCloseKey(hSubkey);
	}
	RegCloseKey(hKey);
	nResult = RegCreateKeyEx(HKEY_CLASSES_ROOT, _T("JEdit.JEditLauncher"), 0, 0, 0,
		KEY_ALL_ACCESS, 0, &hKey, 0);
	if(nResult == ERROR_SUCCESS)
	{
		RegSetValueEx(hKey, 0, 0, REG_SZ, (LPBYTE)(LPCTSTR)strClassName,
			InstallData::GetBufferByteLen(strClassName));
		HKEY hSubkey;
		nResult = RegCreateKeyEx(hKey, _T("CLSID"), 0, 0, 0, KEY_ALL_ACCESS,
			0, &hSubkey, 0);
		if(nResult == ERROR_SUCCESS)
		{
			RegSetValueEx(hSubkey, 0, 0, REG_SZ, (LPBYTE)(LPCTSTR)strGUID,
				InstallData::GetBufferByteLen(strGUID));
		}
		RegCloseKey(hSubkey);
		nResult = RegCreateKeyEx(hKey, _T("CurVer"), 0, 0, 0, KEY_ALL_ACCESS,
			0, &hSubkey, 0);
		if(nResult == ERROR_SUCCESS)
		{
			RegSetValueEx(hSubkey, 0, 0, REG_SZ, (LPBYTE)(LPCTSTR)strCurVer,
				InstallData::GetBufferByteLen(strCurVer));
		}
		RegCloseKey(hSubkey);
	}
	RegCloseKey(hKey);

	// unregister uninstall information for jEdit 3.2
	int nResultDel = RegOpenKeyEx(HKEY_CURRENT_USER,
		_T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
		0, KEY_WRITE, &hKey);
	if(nResultDel == ERROR_SUCCESS)
		RegDeleteKey(hKey, _T("jEdit 3.2"));
	RegCloseKey(hKey);

	if(nResult != ERROR_SUCCESS)
		return E_FAIL;
	return S_OK;
}



HRESULT JELRegistryInstaller::RegisterCmdLineParameters()
{
	bool bResult = true;
	InstallerLog::Log(Message, "Registering command line parameters. . . .\n");
	HKEY hLauncherKey, hVersionKey;
	DWORD dwDisp;
	int nResult;
	DWORD dwValueSize;
	TCHAR szBuf[MAX_PATH];
	TCHAR* arszValues[] = { _T("Java Executable"),
							_T("Java Options"),
							_T("jEdit Target"),
							_T("jEdit Options"),
							_T("jEdit Working Directory"),
							_T("Launcher GUID"),
							_T("Installation Directory"),
							_T("Launcher Log Level") };

	ZeroMemory(szBuf, MAX_PATH);

/*
	enum { JavaExec, JavaOptions, jEditTarget, jEditOptions,
			Server, WorkingDir, GUID, InstallDir };
*/

	// ask if parameters should be retained from last installation
	bool bUseOldParameters = false;
	if((pData->bIs32 || pData->bIs40)	&& IDYES == MessageBox(0,
			"Do you wish to retain command line parameters from your existing installation of jEditLauncher?",
			"jEditLauncher", MB_ICONQUESTION | MB_YESNO))
	{
		InstallerLog::Log(Message, "Using parameters from existing installation.\n");
		bUseOldParameters = true;
	}
	else
	{
		InstallerLog::Log(Message, "Writing default parameters.\n");
	}

	CString strLauncherParamKeyPath((LPCSTR)IDS_REG_LAUNCHER_PARAM_KEY);
	RegCreateKeyEx(HKEY_CURRENT_USER, strLauncherParamKeyPath, 0, 0, 0,
			KEY_ALL_ACCESS, 0, &hLauncherKey, 0);
	CString strVersion(pData->strInstallVersion);
	RegCreateKeyEx(hLauncherKey, strVersion, 0, 0, 0,
		KEY_ALL_ACCESS, 0, &hVersionKey, &dwDisp);

	// rewrite key from 3.2 to 4.0
	if(bUseOldParameters && pData->bIs32 && !pData->bIs40)
	{
		HKEY hKey32;
		int nResult32 = RegOpenKeyEx(hLauncherKey,
			"3.2", 0, KEY_READ, &hKey32);
		if(nResult32 == ERROR_SUCCESS)
		{
			nResult32 = RegCopyKey(hKey32, hLauncherKey, "4.0");
			RegCloseKey(hKey32);
			if(nResult32 == ERROR_SUCCESS)
			{
				InstallerLog::Log(Debug,
					"Copied key information from version 3.2 to 4.0.\n");
				nResult32 = RegDeleteKey(hLauncherKey, _T("3.2"));
				InstallerLog::Log(Debug, "version 3.2 parameters %s\n",
					nResult32 == ERROR_SUCCESS ? "deleted" : "not deleted");
			}
			else
			{
				bUseOldParameters = false;
				InstallerLog::Log(Error,
					"Could not copy parameters from version 3.2 to 4.0, new parameters must be supplied.\n");
			}
		}
		else
		{
			RegCloseKey(hKey32);
			bUseOldParameters = false;
			InstallerLog::Log(Error,
				"Could not find parameters from version 3.2 to copy, new parameters must be supplied.\n");
		}
	}


	// "Java Executable" - set if old parameter or if not available;
	// do not update if user elects to retain old parameters
	dwValueSize = MAX_PATH;
	nResult = RegQueryValueEx(hVersionKey, arszValues[0], 0, 0, (LPBYTE)szBuf, &dwValueSize);
	if(!bUseOldParameters || nResult != ERROR_SUCCESS || dwValueSize == 0)
	{
		CString strJavaExec(pData->strJavaHome);
		strJavaExec += _T("\\javaw.exe");
		nResult = RegSetValueEx(hVersionKey, arszValues[0], 0,
			REG_SZ, (LPBYTE)(LPCTSTR)strJavaExec,
			InstallData::GetBufferByteLen(strJavaExec));
		if(ERROR_SUCCESS == nResult)
		{
			InstallerLog::Log(Debug,
				"Writing \"Java Executable\" registry parameter: %s\n",
				(LPCSTR)strJavaExec);
		}
		else
		{
			InstallerLog::Log(Error,
				"Could not write \"Java Executable\" registry parameter.\n");
			bResult &= false;
		}
	}

	// "Java Options" - set if new parameters of if unavailable;
	// update regardless whenther user elects to retain old parameters
	dwValueSize = MAX_PATH;
	nResult = RegQueryValueEx(hVersionKey, arszValues[1], 0, 0, (LPBYTE)szBuf, &dwValueSize);
	if(!bUseOldParameters || nResult != ERROR_SUCCESS || dwValueSize == 0)
	{
		bUseOldParameters = false;
		CString strJavaOptions(_T("-mx32m -jar"));
//		strJavaOptions.Format(IDS_REG_JAVAPARAM_DEFAULT,
//			pData->arPathNames[pData->nIndexSubjectVer]);
		nResult = RegSetValueEx(hVersionKey, arszValues[1], 0,
			REG_SZ, (LPBYTE)(LPCTSTR)strJavaOptions,
			InstallData::GetBufferByteLen(strJavaOptions));
		if(ERROR_SUCCESS == nResult)
		{
			InstallerLog::Log(Debug,
				"Writing \"Java Options\" registry parameter: %s\n",
				(LPCSTR)strJavaOptions);
		}
		else
		{
			InstallerLog::Log(Error,
				"Could not write \"Java Options\" registry parameter.\n");
			bResult &= false;
		}
	}
	else
	{
		UpdateJarParameter(szBuf);
		nResult = RegSetValueEx(hVersionKey, arszValues[1], 0,
			REG_SZ, (LPBYTE)szBuf,
			(_tcslen(szBuf) + 1) * sizeof(TCHAR));
		if(ERROR_SUCCESS == nResult)
		{
			InstallerLog::Log(Debug,
				"Updating \"Java Options\" registry parameter: %s\n",
				(LPCSTR)szBuf);
		}
		else
		{
			InstallerLog::Log(Error,
				"Could not write \"Java Options\" registry parameter.\n");
			bResult &= false;
		}
	}

	// "jEdit Target" -- must always be set
	CString strJEditTarget;
	dwValueSize = MAX_PATH;
	nResult = RegQueryValueEx(hVersionKey, arszValues[2], 0, 0, (LPBYTE)szBuf, &dwValueSize);
	if(nResult != ERROR_SUCCESS || dwValueSize == 0
		|| strstr(szBuf, "jedit.jar") != 0)
	{
		strJEditTarget = _T("\"");
		strJEditTarget += pData->strInstallDir;
		strJEditTarget += _T("\\jedit.jar\"");
	}
	else
	{
		strJEditTarget = _T("org.gjt.sp.jedit.jEdit");
	}
	nResult = RegSetValueEx(hVersionKey, arszValues[2], 0,
		REG_SZ, (LPBYTE)(LPCTSTR)strJEditTarget,
		InstallData::GetBufferByteLen(strJEditTarget));
	if(ERROR_SUCCESS == nResult)
	{
		InstallerLog::Log(Debug,
			"Writing \"jEdit Target\" registry parameter: %s\n",
			(LPCSTR)strJEditTarget);
	}
	else
	{
		InstallerLog::Log(Error,
			"Could not write \"jEdit Target\" registry parameter.\n");
			bResult &= false;
	}


	// "jEdit Options" - default is no options;
	// make sure an empty item is written
	dwValueSize = MAX_PATH;
	nResult = RegQueryValueEx(hVersionKey, arszValues[3], 0, 0, (LPBYTE)szBuf, &dwValueSize);
	if(!bUseOldParameters || nResult != ERROR_SUCCESS)
	{
		// "jEdit Options"
		char szBuf = 0;
		nResult = RegSetValueEx(hVersionKey, arszValues[3], 0,
			REG_SZ, (LPBYTE)&szBuf, sizeof(TCHAR));
		if(ERROR_SUCCESS == nResult)
		{
			InstallerLog::Log(Debug,
				"Writing empty \"jEdit Options\" registry parameter.\n");
		}
		else
		{
			InstallerLog::Log(Error,
				"Could not write \"jEdit Options\" registry parameter.\n");
			bResult &= false;
		}
	}

	// "jEdit Working Directory"
	// always change working directory, so you can't get
	// an orphan entry following an uninstall of another version

	CString strWorkingDir(pData->strInstallDir);
	nResult = RegSetValueEx(hVersionKey, arszValues[4], 0,
		REG_SZ, (LPBYTE)(LPCTSTR)strWorkingDir,
		InstallData::GetBufferByteLen(strWorkingDir));
	if(ERROR_SUCCESS == nResult)
	{
		InstallerLog::Log(Debug,
			"Writing \"jEdit Working Directory\" registry parameter: %s\n",
			(LPCTSTR)strWorkingDir);
	}
	else
	{
		InstallerLog::Log(Error,
			"Could not write \"jEdit Working Directory\" registry parameter.\n");
		bResult &= false;
	}


	// "Launcher GUID"
	nResult = RegSetValueEx(hVersionKey, arszValues[5], 0,
		REG_SZ, (LPBYTE)(LPCTSTR)pData->strInstallGUID,
		InstallData::GetBufferByteLen(pData->strInstallGUID));
	if(ERROR_SUCCESS == nResult)
	{
		InstallerLog::Log(Debug,
			"Writing \"Launcher GUID\" registry parameter: %s\n",
				(LPCTSTR)pData->strInstallGUID);
	}
	else
	{
		InstallerLog::Log(Error,
			"Could not write \"Launcher GUID\" registry parameter.\n");
		bResult &= false;
	}

	// "Installation Dir"
	nResult = RegSetValueEx(hVersionKey, arszValues[6], 0,
		REG_SZ, (LPBYTE)(LPCTSTR)pData->strInstallDir,
		InstallData::GetBufferByteLen(pData->strInstallDir));
	if(ERROR_SUCCESS == nResult)
	{
		InstallerLog::Log(Debug,
			"Writing \"Installation Dir\" registry parameter: %s\n",
			(LPCTSTR)pData->strInstallDir);
	}
	else
	{
		InstallerLog::Log(Error,
			"Could not write \"Installation Dir\" registry parameter.\n");
		bResult &= false;
	}

	// "Launcher Log Level": set to -1 if not previously set
	dwValueSize = MAX_PATH;
	nResult = RegQueryValueEx(hVersionKey, arszValues[7], 0, 0, (LPBYTE)szBuf, &dwValueSize);
	if(!bUseOldParameters || nResult != ERROR_SUCCESS || dwValueSize == 0)
	{
		DWORD dwDebug = (DWORD)-1;
		nResult = RegSetValueEx(hVersionKey, arszValues[7], 0,
			REG_DWORD, (LPBYTE)&dwDebug, sizeof(DWORD));
		if(ERROR_SUCCESS == nResult)
		{
			InstallerLog::Log(Debug,
				"Writing \"Launcher Log Level\" registry parameter: %d\n",
				dwDebug);
		}
		else
		{
			InstallerLog::Log(Error,
				"Could not write \"Launcher Log Level\" registry parameter.\n");
			bResult &= false;
		}
	}

	RegCloseKey(hVersionKey);
	RegCloseKey(hLauncherKey);
	InstallerLog::Log(Message, "Registration of command line parameters %s.\n",
		bResult ? "succeeded" : "failed");
	return S_OK;
}

// if "jEdit.jar" appears in the parameter,
// get the associated directory and change to the
// current install directory
void JELRegistryInstaller::UpdateJarParameter(LPTSTR lpszParam)
{
	CString strLCParam(lpszParam);
	strLCParam.MakeLower();
	const TCHAR *pJar = lpszParam + strLCParam.Find(_T("jedit.jar"));
	if(pJar <= lpszParam) return;
	bool quoted = false;
	const TCHAR *pStart = lpszParam;
	const TCHAR *p;
	for(p = lpszParam; p < pJar; ++p)
	{
		switch (*p)
		{
			case _T(';'): pStart = p; break;
			case _T(' '): if(!quoted) pStart = p; break;
			case _T('\"'): quoted = !quoted; if(quoted) pStart = p; break;
			default: break;
		}
	}
	// now pStart points to the beginning of the jedit.jar path,
	// or a leading space, quote or semicolon; next we trim
	bool bContinue = true;
	for(p = pStart; bContinue && p < pJar; ++p)
	{
		switch(*p)
		{
			case _T(';'):
			case _T(' '):
			case _T('\"'): pStart = p; break;
			default: bContinue = false; break;
		}
	}
	// now we replace from pStart to pJar with the new install dir
	char szNewParam[MAX_PATH];
	ZeroMemory(szNewParam, MAX_PATH);
	lstrcpyn(szNewParam, lpszParam, pStart - lpszParam);
	lstrcat(szNewParam, pData->strInstallDir);
	lstrcat(szNewParam, _T("\\"));
	lstrcat(szNewParam, pJar);
	lstrcpy(lpszParam, szNewParam);
}


HRESULT JELRegistryInstaller::Uninstall()
{
	UnregisterCmdLineParameters();
	CString strDir(pData->strInstallDir);

	// unregister proxy/stub DLL
	CString strPath(strDir);
	strPath += _T("\\jeservps.dll");
	RegisterDLL(strPath, FALSE);

	// clean up proxy/stub;  this is interface GUID
	CString strPxStubCLSID(_T("CLSID\\{E53269FA-8A5C-42B0-B3BC-82254F4FCED4}"));
	RegDeleteKey(HKEY_CLASSES_ROOT, strPxStubCLSID + _T("\\InProcServer32"));
	RegDeleteKey(HKEY_CLASSES_ROOT, strPxStubCLSID);

	// unregister COM Server
	strPath = strDir;
	strPath += _T("\\jeditsrv.exe");
	RegisterEXE(strPath, FALSE);

	CheckUnregisterCtxMenu();


	// delete HKEY_CLASSES_ROOT\JEdit.JEditLauncher  and interface key if nothing is left
	HKEY hLauncherKey;
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _T("JEdit.JEditLauncher"),
		0, KEY_ALL_ACCESS, &hLauncherKey))
	{
		RegDeleteKey(hLauncherKey, _T("CLSID"));
		RegDeleteKey(hLauncherKey, _T("CurVer"));
		RegCloseKey(hLauncherKey);
		RegDeleteKey(HKEY_CLASSES_ROOT, _T("JEdit.JEditLauncher"));
	}
	CString strInterfaceKey(_T("Interface\\{E53269FA-8A5C-42B0-B3BC-82254F4FCED4}"));
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, strInterfaceKey,
		0, KEY_ALL_ACCESS, &hLauncherKey))
	{
		RegDeleteKey(hLauncherKey, _T("NumMethods"));
		RegDeleteKey(hLauncherKey, _T("ProxyStubClsid"));
		RegDeleteKey(hLauncherKey, _T("ProxyStubClsid32"));
		RegDeleteKey(hLauncherKey, _T("TypeLib"));
		RegCloseKey(hLauncherKey);
		RegDeleteKey(HKEY_CLASSES_ROOT, strInterfaceKey);
	}

	return S_OK;
}

HRESULT JELRegistryInstaller::UnregisterCmdLineParameters()
{
	HKEY hKey;
	// delete command line parameters and any empty parent keys
	CString strLauncherParamKey((LPCSTR)IDS_REG_LAUNCHER_PARAM_KEY);
	int nResult = RegOpenKeyEx(HKEY_CURRENT_USER, strLauncherParamKey,
		0, KEY_ALL_ACCESS,  &hKey);
	if(nResult == ERROR_SUCCESS)
	{
		CString strVersion(pData->strInstallVersion);
		RegDeleteKey(hKey, strVersion);
		DWORD dwSubkeys;
		RegQueryInfoKey(hKey, 0, 0, 0, &dwSubkeys, 0, 0, 0, 0, 0, 0, 0);
		if(dwSubkeys == 0)
		{
			RegCloseKey(hKey);
			if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
				_T("Software\\www.jedit.org"), 0, KEY_ALL_ACCESS, &hKey))
			{
				RegDeleteKey(hKey, _T("jEditLauncher"));
				RegQueryInfoKey(hKey, 0, 0, 0, &dwSubkeys, 0, 0, 0, 0, 0, 0, 0);
				if(dwSubkeys == 0)
				{
					RegCloseKey(hKey);
					if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
						_T("Software"), 0, KEY_ALL_ACCESS, &hKey))
					{
						RegDeleteKey(hKey, _T("www.jedit.org"));
					}
				}
			}
		}
	}
	RegCloseKey(hKey);
	return S_OK;
}

// Unregisters ctx menu handler if the current version is installed
HRESULT JELRegistryInstaller::CheckUnregisterCtxMenu()
{
	// first get the CLSID of the installed handler
	CString strCtxMenuKey((LPCSTR)IDS_REG_CTXMENU_KEY);
	CString strCurCtxMenuCLSID;
	HKEY hCtxMenuKey;
	int nResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strCtxMenuKey, 0,
		KEY_ALL_ACCESS, &hCtxMenuKey);
	if(nResult == ERROR_SUCCESS)
	{
		CStringBuf<>buf(strCurCtxMenuCLSID);
		DWORD dwlength = buf * sizeof(TCHAR);
		nResult = RegQueryValueEx(hCtxMenuKey, 0, 0, 0,
			(LPBYTE)buf, &dwlength);
	}
	RegCloseKey(hCtxMenuKey);

	// now get the path to the handler module from the CLSID
	CString strCurCtxMenuPath;
	CString strServerKey(_T("CLSID\\"));
	strServerKey += strCurCtxMenuCLSID;
	strServerKey += _T("\\InprocServer32");
	nResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strServerKey, 0,
		KEY_ALL_ACCESS, &hCtxMenuKey);
	if(nResult == ERROR_SUCCESS)
	{
		CStringBuf<>buf(strCurCtxMenuPath);
		DWORD dwlength = buf * sizeof(TCHAR);
		nResult = RegQueryValueEx(hCtxMenuKey, 0, 0, 0,
			(LPBYTE)buf, &dwlength);
	}
	RegCloseKey(hCtxMenuKey);

	// NOTE: Ctx menu now always installed
	// now compare the installed handler's path to
	// the path in this version and delete the key if they match
//	CString strPath(pData->arPathNames[pData->nIndexSubjectVer]);
//	strPath += _T("\\jeshlstb.dll");
//	TCHAR szInstalledPath[MAX_PATH], szCurPath[MAX_PATH];
//	GetShortPathName(strCurCtxMenuPath, szInstalledPath, MAX_PATH);
//	GetShortPathName(strPath, szCurPath, MAX_PATH);
//	HRESULT hr = S_OK;
//	if(_tcsicmp(szInstalledPath, szCurPath) == 0)
//	{
		RegDeleteKey(HKEY_CLASSES_ROOT, strCtxMenuKey);
		RegisterDLL(strCurCtxMenuPath, FALSE);
//	}
//	else hr = S_FALSE;
	return S_OK;
}

HRESULT JELRegistryInstaller::SendMessage(LPVOID p)
{
	p;
	return E_NOTIMPL;
}


LONG JELRegistryInstaller::RegCopyKey(HKEY SrcKey, HKEY TrgKey, TCHAR* TrgSubKeyName)
{
	HKEY	SrcSubKey;
	HKEY	TrgSubKey;
	int	ValEnumIndx=0;
	int	KeyEnumIndx=0;
	char	ValName[MAX_PATH+1];
	char	KeyName[MAX_PATH+1];
	DWORD	size;
	DWORD	VarType;
	LONG     nResult;
	DWORD	KeyDisposition;
	FILETIME LastWriteTime;
	CString strBuffer;

	// create target key
	nResult = RegCreateKeyEx(TrgKey, TrgSubKeyName, NULL, NULL,
		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &TrgSubKey,
		&KeyDisposition);
	if(nResult != ERROR_SUCCESS)
		return nResult;

	do {
		do {
			// read value from source key
			CStringBuf<1024> buffer(strBuffer);
			ULONG buffSize = (ULONG)buffer.Size();
			size=MAX_PATH+1;
			nResult = RegEnumValue(SrcKey, ValEnumIndx, ValName, &size,
				NULL, &VarType, buffer, &buffSize);

			// done copying this key
			if (nResult == ERROR_NO_MORE_ITEMS)
			{
				nResult = ERROR_SUCCESS;
				break;
			}
			if(nResult != ERROR_SUCCESS)
				break;
			// write value to target key
			nResult = RegSetValueEx(TrgSubKey, ValName, NULL, VarType,
				buffer, buffSize);
			if(nResult != ERROR_SUCCESS)
				break;
			// read next value
			ValEnumIndx++;
		} while (nResult == ERROR_SUCCESS);
		// if copying under the same key avoid endless recursions
		TCHAR TrgSubKeyNameRoot[1024];
		do {
			// enum sub keys
			size=MAX_PATH+1;
			nResult = RegEnumKeyEx(SrcKey, KeyEnumIndx++, KeyName, &size,
				NULL, NULL, NULL, &LastWriteTime);
			lstrcpyn(TrgSubKeyNameRoot, TrgSubKeyName, lstrlen(TrgSubKeyName) + 1);

		} while ((SrcKey == TrgKey) &&
			(nResult == ERROR_SUCCESS) &&
			!lstrcmpi(KeyName, TrgSubKeyNameRoot));

		// done copying this key
		if (nResult == ERROR_NO_MORE_ITEMS)
			break;

		// unknown error return
		if (nResult != ERROR_SUCCESS)
			break;

		// open the source subkey
		InstallerLog::Log(Debug, "Opening sub key %s\n", KeyName);
		nResult = RegOpenKeyEx(SrcKey, KeyName, NULL, KEY_ALL_ACCESS,
			&SrcSubKey);
		if(nResult != ERROR_SUCCESS)
			break;

		// recurs with the subkey
		nResult  = RegCopyKey(SrcSubKey, TrgSubKey, KeyName);
		if(nResult != ERROR_SUCCESS)
			break;

		nResult = RegCloseKey(SrcSubKey);
		if(nResult != ERROR_SUCCESS)
			break;
	} while (true);

	RegCloseKey(TrgSubKey);
	if (nResult == ERROR_NO_MORE_ITEMS)
		return ERROR_SUCCESS;
	else
		return nResult;
}

