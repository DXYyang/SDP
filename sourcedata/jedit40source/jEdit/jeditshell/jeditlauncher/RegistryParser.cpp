/*
 * RegistryParser.cpp - part of the jEdit Launcher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: RegistryParser.cpp,v 1.3 2002/01/22 19:06:06 jgellene Exp $
 */


#include "stdafx.h"
#include "resource.h"
#include "JELauncher.h"
#include "LauncherLog.h"
#include "RegistryParser.h"

#include <assert.h>

RegistryParser::RegistryParser()
	: m_bIsInit(FALSE)
{
	HKEY hKey;
	TCHAR szKeyPath[MAX_PATH];
	// parameter IDS_REG_PARAMS_KEY_4_0 is version-specific
	LoadString(_Module.GetModuleInstance(), IDS_REG_PARAMS_KEY_4_0,
		szKeyPath, MAX_PATH);
	if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, szKeyPath,
		0, KEY_READ, &hKey))
	{
		LauncherLog::Log(Error,
			"Could not find registry key for command line parameters.\n");
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_REGISTRY_KEY);
	}
	else if(InitCmdLine(hKey) && InitWorkingDir(hKey))
	{
		m_bIsInit = InitServerPath();
	}
	RegCloseKey(hKey);
	hKey = 0;
}

RegistryParser::~RegistryParser() {}

LPCTSTR RegistryParser::GetCommandLine()
{
	return m_strCmdLine;
}

LPCTSTR RegistryParser::GetServerFilePath()
{
	return m_strServerPath;
}

LPCTSTR RegistryParser::GetWorkingDirectory()
{
	return m_strWorkingDir;
}


BOOL RegistryParser::InitCmdLine(HKEY hKey)
{
	TCHAR szExec[MAX_PATH];
	ZeroMemory(szExec, MAX_PATH * sizeof(TCHAR));
	BOOL bResult = FetchRegParam(hKey, _T("Java Executable"),
		szExec, IDS_ERR_NO_JAVA_EXEC_VALUE);
	bResult &= FetchRegParam(hKey, _T("Java Options"), szExec, 0);
	bResult &= FetchRegParam(hKey, _T("jEdit Target"),
		szExec, IDS_ERR_NO_JEDIT_TARGET_VALUE);
	bResult &= FetchRegParam(hKey, _T("jEdit Options"), szExec, 0);
	ExpandEnvironmentStrings(szExec, m_strCmdLine, MAX_PATH * 2);
	return bResult;
}

BOOL RegistryParser::FetchRegParam(HKEY hKey, LPCTSTR szParam,
	LPTSTR szCmdLine, UINT nError)
{
	TCHAR szTemp[MAX_PATH];
	DWORD dwType, dwCount = MAX_PATH;
	int nResult = RegQueryValueEx(hKey, szParam, 0,
		&dwType, (LPBYTE)szTemp, &dwCount);
	if(nResult != ERROR_SUCCESS)
	{
		if(nError != 0)
			CJEditLauncher::MakeErrorInfo(nError);
	}
	else
	{
		if(*szCmdLine != 0)
			lstrcat(szCmdLine, " ");
		lstrcat(szCmdLine, szTemp);
	}
	return nResult == ERROR_SUCCESS;
}

BOOL RegistryParser::InitWorkingDir(HKEY hKey)
{
	*m_strWorkingDir = 0;
	return FetchRegParam(hKey, _T("jEdit Working Directory"),
		m_strWorkingDir, IDS_ERR_NO_JEDIT_WORKINGDIR_VALUE);
}

BOOL RegistryParser::InitServerPath()
{
	TCHAR szServerPath[MAX_PATH];
	ZeroMemory(szServerPath, MAX_PATH * sizeof(TCHAR));
	if(strlen(m_strCmdLine) == 0)
		return FALSE;
	// look first for -settings parameter, then user.home definition
	BOOL bFoundInSettings =
		FetchCmdParam(m_strCmdLine, _T("-settings="), szServerPath);
	if(*szServerPath == 0)
	{
		FetchCmdParam(m_strCmdLine, _T("user.home="), szServerPath);
	}
	if(*szServerPath == 0)
	{
		// directory: %USERPROFILE%  for NT/2000,
		//            %HOME% or %WINDIR% for 95/98/Me
		OSVERSIONINFO osver;
		osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		GetVersionEx(&osver);
		if(osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			GetEnvironmentVariable("USERPROFILE", szServerPath, MAX_PATH);
		}
		else  // Win95/98/Me
		{
			if(0 == GetEnvironmentVariable("HOME", szServerPath, MAX_PATH))
				GetEnvironmentVariable("WINDIR", szServerPath, MAX_PATH);
		}
	}
	if(!bFoundInSettings)
		lstrcat(szServerPath, _T("\\.jedit"));
	lstrcat(szServerPath, _T("\\"));
	// now look for server
	if(!FetchCmdParam(m_strCmdLine, _T("-server="), szServerPath))
	{
		lstrcat(szServerPath, _T("server"));
	}
	ExpandEnvironmentStrings(szServerPath, m_strServerPath, MAX_PATH);
//	LauncherLog::Log(Debug, "Server path is: %s\n", m_strServerPath);
	return TRUE;
}

BOOL RegistryParser::FetchCmdParam(LPCTSTR strSource, LPCTSTR szParam,
	LPTSTR szDest)
{
	char* pFind = strstr(strSource, szParam);
	if(pFind == 0)	return FALSE;
	const TCHAR *pSrc = pFind + lstrlen(szParam);
	TCHAR *pDest = szDest + lstrlen(szDest);
	TCHAR *pStartDest = pDest;
	while(*pSrc && isspace(*pSrc)) ++pSrc;
	TCHAR settingsStop = (*pSrc == _T('\"')) ? _T('\"') : _T(' ');
	if(*pSrc != 0 && *pSrc != '\"')
		*pDest++ = *pSrc;
	++pSrc;
	while(*pSrc != 0 && *pSrc != settingsStop)
		*pDest++ = *pSrc++;
	return pDest != pStartDest;
}

