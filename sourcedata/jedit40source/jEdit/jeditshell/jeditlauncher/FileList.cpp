/*
 * FileList.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: FileList.cpp,v 1.5 2002/03/24 16:56:42 jgellene Exp $
 */

#include "stdafx.h"
#include "resource.h"
#include "JELauncher.h"
#include "ScriptServer.h"
#include "ScriptWriter.h"
#include "FileList.h"
#include "LauncherLog.h"
#include <stdio.h>

FileListImpl::FileListImpl(ScriptWriter *pWriter)
		: m_pWriter(pWriter) {}

FileListImpl::~FileListImpl()
{
	delete m_pWriter;
}

ScriptWriter* FileListImpl::GetWriter()
{
	return m_pWriter;
}

char** FileListImpl::GetData(char** ppData, int numArgs)
{
	char **ppRet = (char**)CoTaskMemAlloc(sizeof(char*) * numArgs);
	*ppRet = (char*)CoTaskMemAlloc(sizeof(char) * MAX_PATH * numArgs);
	char *pDest = *ppRet;
	char **ppSource = ppData;
	for(int i = 0; i < numArgs; ++i, ++ppSource)
	{
		strcpy(pDest, *ppSource);
		ppRet[i] = pDest;
		pDest += MAX_PATH;
	}
	return ppRet;
}

void FileListImpl::DeleteData(char **ppData)
{
	CoTaskMemFree(*ppData);
	CoTaskMemFree(ppData);
}

wchar_t** FileListImpl::GetData(wchar_t** ppData, int numArgs)
{
	wchar_t **ppRet = (wchar_t**)CoTaskMemAlloc(sizeof(wchar_t*) * numArgs);
	*ppRet = (wchar_t*)CoTaskMemAlloc(sizeof(wchar_t) * MAX_PATH * numArgs);
	wchar_t *pDest = *ppRet;
	wchar_t **ppSource = ppData;
	for(int i = 0; i < numArgs; ++i, ++ppSource)
	{
		wcscpy(pDest, *ppSource);
		ppRet[i] = pDest;
		pDest += MAX_PATH;
	}
	return ppRet;
}

void FileListImpl::DeleteData(wchar_t **ppData)
{
	CoTaskMemFree(*ppData);
	CoTaskMemFree(ppData);
}


SimpleFileList::SimpleFileList(ScriptWriter* pWriter, char **argv, int numArgs)
		: FileListImpl(pWriter), m_ppArgs(0), m_nArgs(numArgs)
{
	m_ppArgs = GetData(argv, numArgs);
}

SimpleFileList::~SimpleFileList()
{
	DeleteData(m_ppArgs);
}

HRESULT SimpleFileList::Process(IScriptServer* pServer)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling Process() on SimpleFileList with %d arguments.\n",
//		m_nArgs);
	char* pScript = 0;
	HRESULT hr = GetWriter()->WriteScript(m_ppArgs, m_nArgs, &pScript);
	if(SUCCEEDED(hr))
		hr = SendToServer(pScript, pServer);
	return hr;
}

SimpleFilePair::SimpleFilePair(ScriptWriter* pWriter, char* arg1, char* arg2)
		: FileListImpl(0), m_pImpl(0)
{
	char *args[2];
	args[0] = arg1;
	args[1] = arg2;
	m_pImpl = new SimpleFileList(pWriter, args, 2);
}

SimpleFilePair::~SimpleFilePair()
{
	delete m_pImpl;
}

HRESULT SimpleFilePair::Process(IScriptServer* pServer)
{
	if(m_pImpl == 0) return E_FAIL;
	return m_pImpl->Process(pServer);
}


WideFileList::WideFileList(ScriptWriter* pWriter, wchar_t **argv, int numArgs)
		: FileListImpl(pWriter), m_ppArgs(0), m_nArgs(numArgs)
{
	m_ppArgs = GetData(argv, numArgs);
}

WideFileList::~WideFileList()
{
	DeleteData(m_ppArgs);
}

HRESULT WideFileList::Process(IScriptServer* pServer)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling Process() on WideFileList with %d arguments.\n",
//		m_nArgs);
	char* pScript = 0;
	HRESULT hr = GetWriter()->WriteScript(m_ppArgs, m_nArgs, &pScript);
	if(SUCCEEDED(hr))
		hr = SendToServer(pScript, pServer);
	return hr;
}

WideFilePair::WideFilePair(ScriptWriter* pWriter, wchar_t* arg1, wchar_t* arg2)
		: FileListImpl(0), m_pImpl(0)
{
	wchar_t *args[2];
	args[0] = arg1;
	args[1] = arg2;
	m_pImpl = new WideFileList(pWriter, args, 2);
}

WideFilePair::~WideFilePair()
{
	delete m_pImpl;
}

HRESULT WideFilePair::Process(IScriptServer* pServer)
{
	if(m_pImpl == 0) return E_FAIL;
	return m_pImpl->Process(pServer);
}

VariantFileList::VariantFileList(ScriptWriter *pWriter, VARIANTARG &var)
		: FileListImpl(pWriter), m_var()
{
	::VariantInit(&m_var);
	::VariantCopy(&m_var, &var);
}

VariantFileList::~VariantFileList()
{
	::VariantClear(&m_var);
}

HRESULT VariantFileList::Process(IScriptServer* pServer)
{
	LauncherLog::Log(Debug,
		"[launcher] Calling Process() on VariantFileList\n");
	char* pScript = 0;
	HRESULT hr = GetWriter()->WriteScript(m_var, &pScript);
	LauncherLog::Log(Debug, "Script is %s\n", pScript);
	if(SUCCEEDED(hr))
		hr = SendToServer(pScript, pServer);
	return hr;
}

BeanShellFileList::BeanShellFileList(char* pszScript, bool isFile)
	: FileListImpl(0), m_pszScript(0), m_bIsFile(isFile)
{
	m_pszScript = (char*)CoTaskMemAlloc(max(MAX_PATH, strlen(pszScript) + 16));
	strcpy(m_pszScript, pszScript);
	if(m_bIsFile)
		ScriptWriter::MakeFullPath(m_pszScript);
}

BeanShellFileList::BeanShellFileList(wchar_t* pwszScript, bool isFile)
	: FileListImpl(0), m_pszScript(0), m_bIsFile(isFile)
{
	long size = wcslen(pwszScript);
	m_pszScript = (char*)CoTaskMemAlloc(max(MAX_PATH, size + 16));
	m_bOwnPtr = true;
	ZeroMemory(m_pszScript, size + 16);
	::WideCharToMultiByte(CP_ACP, 0, pwszScript,
		wcslen(pwszScript), m_pszScript, size, 0, 0);
	if(m_bIsFile)
		ScriptWriter::MakeFullPath(m_pszScript);
}


BeanShellFileList::~BeanShellFileList()
{
	CoTaskMemFree(m_pszScript);
}

HRESULT BeanShellFileList::Process(IScriptServer* pServer)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling Process() on BeanShellFileList with script member: %s\n",
//		m_pszScript);
	char buffer[1024];
	::ZeroMemory(buffer, 1024);
	strcpy(buffer, "String param = \"");
	char *p = m_pszScript;
	char *d = buffer + strlen(buffer);
	while(*p != 0)
	{
		if(*p == '\"' || *p == '\\')
			*d++ = '\\';
		*d++ = *p++;
	}
	if(m_bIsFile)
	{
		strcat(buffer,
			"\";\nBeanShell.runScript(jEdit.getFirstView(),param,true,true);");
	}
	else
	{
		strcat(buffer,
			"\";\nBeanShell.eval(jEdit.getFirstView(),param,true);");
	}
	return SendToServer(buffer, pServer);
}


HRESULT FileListImpl::SendToServer(char* szBuf, IScriptServer* pServer)
{
	if(pServer == 0)
		return E_FAIL;
	return pServer->ProcessScript((unsigned char*)szBuf);
}


