/*
 * JELauncher.cpp - part of jEditLauncher package
 * Copyright (C) 2001, 2002 John Gellene
 * jgellene@nyc.rr.com
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: JELauncher.cpp,v 1.10 2002/03/24 16:56:42 jgellene Exp $
 */


#include "stdafx.h"
#include "Jeditlauncher.h"
#include "FileList.h"
#include "ScriptWriter.h"
#include "RegistryParser.h"
#include "JELauncher.h"
#include "LauncherLog.h"
#include <assert.h>

/////////////////////////////////////////////////////////////////////////////
// CJEditLauncher

CJEditLauncher::CJEditLauncher()
	: m_bRunDiff(FALSE), m_pFileList(0),
	  m_pScriptServer(0), m_pRegParser(0),
	  m_hJEditProcess(0),
	  m_bSendScriptOnLaunch(FALSE),
	  m_nIDTimer(0), m_nCounter(0),
	  m_nDelayedRelease(0)
{
	m_pRegParser = new RegistryParser();
	m_pScriptServer = new CScriptServer(m_pRegParser);
	_Module.pLauncher = this;
	LauncherLog::Init();
}


CJEditLauncher::~CJEditLauncher()
{
	LauncherLog::Exit();
	_Module.pLauncher = 0;
	delete m_pFileList;
	delete m_pScriptServer;
	delete m_pRegParser;
}

STDMETHODIMP CJEditLauncher::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IJEditLauncher
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (::ATL::InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// IJEditLauncher implementation

// public interface functions
// the get functions will set the out parameter to 0
// if the server file cannot be located

STDMETHODIMP CJEditLauncher::get_ServerKey(ULONG * pKey)
{
	return m_pScriptServer->GetServerKey(pKey);
}


STDMETHODIMP CJEditLauncher::get_ServerPort(ULONG * pPort)
{
	return m_pScriptServer->GetServerPort(pPort);
}

STDMETHODIMP CJEditLauncher::RunScript(BSTR bstrFileName)
{
	wchar_t* pwszPath = (wchar_t*)bstrFileName;
	return RunScript_WChar(pwszPath);
}

STDMETHODIMP CJEditLauncher::RunScript_WChar(wchar_t* pwszFileName)
{
	if(pwszFileName == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	m_pFileList = new BeanShellFileList(pwszFileName, true);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::RunScript_Char(char* pszFileName)
{
	if(pszFileName == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	m_pFileList = new BeanShellFileList(pszFileName, true);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::EvalScript(BSTR bstrFileName)
{
	wchar_t* pwszPath = (wchar_t*)bstrFileName;
	return EvalScript_WChar(pwszPath);
}

STDMETHODIMP CJEditLauncher::EvalScript_Char(char* pszScript)
{
	if(pszScript == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	m_pFileList = new BeanShellFileList(pszScript, true);
	return RunTarget(TRUE);
};


STDMETHODIMP CJEditLauncher::EvalScript_WChar(wchar_t* pwszScript)
{
	if(pwszScript == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	m_pFileList = new BeanShellFileList(pwszScript, false);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::RunDiff_Var(VARIANTARG varFileNames)
{
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenDiffScript();
	m_pFileList = new VariantFileList(pWriter, varFileNames);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::RunDiff(BSTR bstrFileBase,
	BSTR bstrFileChanged)
{
	wchar_t *pwszFileBase = (wchar_t*)bstrFileBase;
	wchar_t *pwszFileChanged = (wchar_t*)bstrFileChanged;
	return RunDiff_WChar(pwszFileBase, pwszFileChanged);
}

STDMETHODIMP CJEditLauncher::RunDiff_WChar(wchar_t* pwszFileBase,
			wchar_t* pwszFileChanged)
{
	if(pwszFileBase == 0 || pwszFileChanged == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenDiffScript();
	m_pFileList = new WideFilePair(pWriter, pwszFileBase, pwszFileChanged);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::RunDiff_Char(char* pszFileBase,
	char* pszFileChanged)
{
	if(pszFileBase == 0 || pszFileChanged == 0)
		return E_FAIL;
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenDiffScript();
	m_pFileList = new SimpleFilePair(pWriter, pszFileBase, pszFileChanged);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::OpenFile(BSTR bstrFileName)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFile() with wide char parameter.\n");
	wchar_t* pwszPath = (wchar_t*)bstrFileName;
	return OpenFile_WChar(pwszPath);
}

STDMETHODIMP CJEditLauncher::RunTarget(BOOL bSendScript)
{
	// NOTE: const is number of timer cycles for server activation
	const int nTimerCycleLimit = 80;
	// NOTE: const is duration of timer loop waiting for server to activate
	const int nTimerCycleDuration = 500;
	// NOTE: values of 80 and 500 create maximum wait time of 40 seconds
	m_bSendScriptOnLaunch = bSendScript;
	HRESULT hr = S_OK;
	VARIANT_BOOL bVarFound;
	// NOTE: Find and read the file containing server information
	m_pScriptServer->FindServer(&bVarFound);
	// NOTE: function returns VARIANT_TRUE if server is found and is read
	if(bVarFound == VARIANT_TRUE)
	{
		if(!m_bSendScriptOnLaunch)
			return hr;
		// NOTE:  Process() causes the server connection to be attempted
		hr = m_pFileList->Process(m_pScriptServer);
		if(hr == S_OK)
		{
			delete m_pFileList;
			m_pFileList = 0;
			return hr;
		}
	}
	// NOTE:  Launch jEdit if no server file or connection fails
	m_pScriptServer->ClearServer();
	hr = Launch();
	if(hr == S_OK)
	{
		// NOTE: when the timer fires there will be a recheck for the
		m_nCounter = nTimerCycleLimit;
		m_nIDTimer = ::SetTimer(0, 0, nTimerCycleDuration, LaunchTimerProc);
	}
	return hr;
}

// version 3.2 uses OpenFileScript

STDMETHODIMP CJEditLauncher::OpenFiles(VARIANTARG fileNames)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFiles() passing VARIANT parameter.\n");
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenFileScript;
	m_pFileList = new VariantFileList(pWriter, fileNames);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::Launch()
{
	if(m_hJEditProcess != 0)
	{
		DWORD dwResult = WaitForSingleObject(m_hJEditProcess, 0);
		if(dwResult == WAIT_TIMEOUT)
			return S_OK;
		else m_hJEditProcess = 0;
	}
	char* pScript = 0;
	char* pDummy = 0;
	StartAppScript script(m_pRegParser->GetCommandLine());
	script.WriteScript(&pDummy, 0, &pScript);
	return Launch_jEdit(pScript);
}

STDMETHODIMP CJEditLauncher::OpenFile_Char(CHAR* szFileName)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFile_Char() passing char parameter: %s\n",
//		szFileName);
	return OpenFiles_Char(&szFileName, 1);
}

STDMETHODIMP CJEditLauncher::OpenFile_WChar(WCHAR* wszFileName)
{
//	LauncherLog::Log(Debug, "[launcher] Calling OpenFile_WChar().\n");
	return OpenFiles_WChar(&wszFileName, 1);
}


STDMETHODIMP CJEditLauncher::OpenFiles_Char(char **argv, int numArgs)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFiles_Char() with %d arguments.\n",
//		numArgs);
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenFileScript;
	m_pFileList = new SimpleFileList(pWriter, argv, numArgs);
	return RunTarget(TRUE);
}

STDMETHODIMP CJEditLauncher::OpenFiles_WChar(wchar_t **argv, int numArgs)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFiles_WChar() with %d arguments.\n",
//		numArgs);
	delete m_pFileList;
	m_pFileList = 0;
	ScriptWriter *pWriter = new OpenFileScript;
	m_pFileList = new WideFileList(pWriter, argv, numArgs);
	return RunTarget(TRUE);
}


HRESULT CJEditLauncher::Launch_jEdit(char* szCmdLine)
{
//	LauncherLog::Log(Debug, "[launcher] Calling Launch_jEdit()\n");
	LauncherLog::Log(Debug, "[launcher] Command line: %s\n", szCmdLine);
	const char* pWDir = m_pRegParser->GetWorkingDirectory();
	LauncherLog::Log(Debug,
		"[launcher] Working directory: %s\n",
		pWDir ? pWDir : "<inherited from calling process>");
	STARTUPINFO si;
	::ZeroMemory(&si, sizeof(si));
	PROCESS_INFORMATION pi;
	const char *pWorkingDirectory = m_pRegParser->GetWorkingDirectory();
	if(*pWorkingDirectory == 0)
		pWorkingDirectory = 0;
	BOOL bReturn = CreateProcess(0, szCmdLine,
		0, 0, 0, 0, 0, pWorkingDirectory, &si, &pi);
	if(!bReturn)
	{
		DWORD dwError = GetLastError();
		LPSTR szErrMsg;
		::FormatMessageA(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPSTR) &szErrMsg,
			0,
			NULL
		);
		MakeErrorInfo(szErrMsg);
		LauncherLog::Log(MsgLevel(0),
			"[launcher] Error calling CreateProcess() in launch routine. Error code: %d - %s\n",
			dwError, szErrMsg);
		::LocalFree((LPVOID)szErrMsg);
	}
	else
		m_hJEditProcess = pi.hProcess;
	return bReturn ? S_OK : E_FAIL;
}


// provides error string from string table
// resource to be returned to script engine;
// available from C or C++ client code by calling ::GetErrorInfo()

void CJEditLauncher::MakeErrorInfo(UINT nErrorStringID)
{
	if(nErrorStringID == 0)
	{
		::SetErrorInfo(0L, 0);
		return;
	}
	CHAR errorMsg[256];
	HINSTANCE hInstance = _Module.GetModuleInstance();
	LoadString(hInstance, nErrorStringID, errorMsg, 255);

	if(*errorMsg == 0)
		LoadString(hInstance, IDS_ERR_UNSPECIFIED, errorMsg, 255);
	MakeErrorInfo(errorMsg);
}

void CJEditLauncher::MakeErrorInfo(CHAR* pszErrorMsg)
{
	if(pszErrorMsg == 0)
		return;
	int len = strlen(pszErrorMsg);
	WCHAR pwszErrorMsg[256];
	ZeroMemory(pwszErrorMsg, sizeof(WCHAR) * 256);
	MultiByteToWideChar(CP_ACP, 0, pszErrorMsg, len, pwszErrorMsg, len);
	ICreateErrorInfo *piCreateErr = 0;
	HRESULT hr = ::CreateErrorInfo( &piCreateErr);
	if(FAILED(hr))
		return;
	//piCreateErr->SetHelpFile(...);
	//piCreateErr->SetHelpContext(...);
	piCreateErr->SetSource(L"JEdit.JEditLauncher");
	piCreateErr->SetDescription(pwszErrorMsg);

	IErrorInfo *piError = 0;
	hr = piCreateErr->QueryInterface(IID_IErrorInfo, (void**)&piError);
	if(SUCCEEDED(hr))
	{
		::SetErrorInfo(0L, piError);
		piError->Release();
	}
	piCreateErr->Release();
}

void CJEditLauncher::OnTimer(UINT nIDTimer)
{
	if(nIDTimer != m_nIDTimer) return;
	VARIANT_BOOL bVarFound;
	LauncherLog::Log(Debug,
		"[launcher] Timer fired; search for server file.\n");
	m_pScriptServer->FindServer(&bVarFound);
	if(bVarFound == VARIANT_TRUE || m_nCounter == 0)
	{
		LauncherLog::Log(Debug,	"[launcher] Killing timer.\n");
		BOOL bKilled = KillTimer(0, m_nIDTimer);
		LauncherLog::Log(Debug,
			(bKilled ? "[launcher] Timer killed.\n" :
			"[launcher] Timer not killed.\n"));
		m_nIDTimer = 0;
		if(bVarFound == VARIANT_TRUE && m_bSendScriptOnLaunch)
		{
			assert(m_pFileList);
			assert(m_pScriptServer);
			m_pFileList->Process(m_pScriptServer);
			delete m_pFileList;
			m_pFileList = 0;
			LauncherLog::Log(Debug, "[launcher] File list processed.\n");
		}
		LauncherLog::Log(Debug, "[launcher] Delayed release of launcher module.\n");
		while(m_nDelayedRelease-- > 0)
		{
			_Module.Unlock();
		}
	}
	else --m_nCounter;
}


void CALLBACK LaunchTimerProc(HWND hwnd, UINT uMsg,
	UINT_PTR idEvent, DWORD dwTime)
{
//	LauncherLog::Log(Debug, "Timer fired.\n", 0);
	_Module.pLauncher->OnTimer(idEvent);
}


