/*
 * ScriptWriter.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: ScriptWriter.cpp,v 1.11 2002/02/21 05:34:18 jgellene Exp $
 */

#include "stdafx.h"
#include "resource.h"
#include "JELauncher.h"
#include "ScriptWriter.h"
#include "LauncherLog.h"
#include <shlobj.h>

// implementation of ScriptWriter class

ScriptWriter::ScriptWriter()
	: pBuffer(0), pPathBuffer(0), bufferSize(0L) {}


ScriptWriter::~ScriptWriter()
{
	ReleaseBuffer();
}


HRESULT ScriptWriter::WriteScript(VARIANTARG var, char** ppScript)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::WriteScript() passing variant.\n");
	WritePrefix();
	ProcessPathArray(var);
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::WriteScript(wchar_t* wargv[], int nArgs,
		char **ppScript)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::WriteScript() passing wide char array\n");
	WritePrefix();
	for(wchar_t **pp = wargv; nArgs > 0; --nArgs, ++pp)
	{
		ProcessPath(*pp);
	}
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::WriteScript(char* argv[], int nArgs,
		char **ppScript)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::WriteScript() passing char array\n");
	WritePrefix();
	for(char **pp = argv; nArgs > 0; --nArgs, ++pp)
	{
		ProcessPath(*pp);
	}
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::InitBuffer(size_t size)
{
	if(pPathBuffer == 0 &&
		(pPathBuffer = (char*)CoTaskMemAlloc(1024)) == 0)
		return E_FAIL;
	char *pBuf = pBuffer;
	pBuffer = (char*)CoTaskMemRealloc(pBuf, (ULONG)size);
	if(pBuffer == 0)
	{
		pBuffer = pBuf;
		return E_FAIL;
	}
	bufferSize = size;
	return S_OK;
}


void ScriptWriter::ReleaseBuffer()
{
	CoTaskMemFree((LPVOID)pBuffer);
	CoTaskMemFree((LPVOID)pPathBuffer);
	pBuffer = 0;
	bufferSize = 0;
	pPathBuffer = 0;
}


void ScriptWriter::ClearBuffer()
{
	ZeroMemory(pBuffer, bufferSize);
}


char* ScriptWriter::GetBuffer()
{
	return pBuffer;
}


HRESULT ScriptWriter::CheckBuffer(size_t sizeCheck, size_t sizeIncr)
{
	size_t needed = 0;
	size_t target = strlen(pBuffer) + sizeCheck;
	while(target + needed > bufferSize - 1)
		needed += sizeIncr;
	return needed != 0 ? InitBuffer(bufferSize + needed) : S_OK;
}


HRESULT ScriptWriter::ProcessPathArray(VARIANTARG arg)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::ProcessPathArray() passing variant\n");
	HRESULT hr;
	VARIANT varPath;
	VariantInit(&varPath);
	switch(arg.vt)
	{
		case VT_BSTR:   // single string in JScript or VBScript
		{
			hr = ProcessPath(arg.bstrVal);
			break;
		}

		case VT_DISPATCH:  // JScript array
		{
			DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
			hr = arg.pdispVal->Invoke( DISPID_NEWENUM, IID_NULL,
					LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
					&dispparamsNoArgs, &varPath, NULL, NULL);
			IEnumVARIANT *pEnum = 0;
			hr = varPath.punkVal->QueryInterface(__uuidof(IEnumVARIANT),
				(void**)&pEnum);
			VariantClear(&varPath);
			HRESULT loop_hr = pEnum->Next(1, &varPath, 0);
			while(loop_hr == S_OK)
			{
				ProcessPath(varPath.bstrVal);
				VariantClear(&varPath);
				loop_hr = pEnum->Next(1, &varPath, 0);
			}
			if(pEnum)
				pEnum->Release();
			break;
		}

		case VT_ARRAY | VT_VARIANT:  // VBScript array
		{
			LONG nIndex = 0;
			HRESULT loop_hr = SafeArrayGetElement(arg.parray,
				&nIndex, &varPath);
			while(loop_hr == S_OK)
			{
//				LauncherLog::Log(Debug, "Script is %s\n", GetBuffer());
				ProcessPath(varPath.bstrVal);
				VariantClear(&varPath);
				loop_hr = SafeArrayGetElement(arg.parray,
					&(++nIndex), &varPath);
			}
			break;
		}
		default:
			hr = E_INVALIDARG;
	}
	VariantClear(&varPath);
//	LauncherLog::Log(Debug, "Script is %s\n", GetBuffer());
	return hr;
}


HRESULT ScriptWriter::ProcessPath(wchar_t* pwszPath)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::ProcessPath with wide char parameter.\n");
	if(pwszPath == 0 || wcslen(pwszPath) == 0)
	{
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_FILENAME);
		return E_FAIL;
	}
	::WideCharToMultiByte(CP_ACP, 0, pwszPath,
		-1, pPathBuffer, MAX_PATH * 2, 0, 0);
	return ProcessPath(pPathBuffer);
}


HRESULT ScriptWriter::ProcessPath(char* pszName)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::ProcessPath with char parameter %s\n",
//		pszName);
	CJEditLauncher::MakeErrorInfo((UINT)0);
	// new
	CHAR pszPath[MAX_PATH];
	CHAR* pFileName = 0;
	GetFullPathName(pszName, MAX_PATH, pszPath, &pFileName);
	//OutputDebugString(pszPath);
	// wild card search and expansion
	if(strcspn(pszPath, "*?") != strlen(pszPath))
	{
		LauncherLog::Log(Debug,
			"[launcher] ScriptWriter::ProcessPath() performing wild-card expansion\n");

		CHAR* pSlash = strrchr(pszPath, '\\');
		UINT pathLen = pSlash ? (UINT)(pSlash - pszPath) + 1 : 0;
		BOOL bDotNoStar = FALSE;
		CHAR* pDot = strrchr(pszPath, '.');
		if(pDot != 0 && strchr(pDot, '*') == 0)
			bDotNoStar = TRUE;
//		LauncherLog::Log(Debug, bDotNoStar ? "bDotNoStar is TRUE" : "bDotNoStar is FALSE");
		UINT maskExtLen = strlen(strrchr(pszPath, '.'));
		CHAR pszRecursivePath[MAX_PATH];
		WIN32_FIND_DATA finddata;
		HANDLE findHandle = FindFirstFile(pszPath, &finddata);
		if(findHandle != INVALID_HANDLE_VALUE)
		{
			BOOL findResult = TRUE;
			while (findResult)
			{
				LauncherLog::Log(Debug, "FileFound: %s\n", finddata.cFileName);
				if((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
					&& (!bDotNoStar || maskExtLen ==
						strlen(strrchr(finddata.cFileName, '.'))))
				{
					strncpy(pszRecursivePath, pszPath, pathLen);
					pszRecursivePath[pathLen] = 0;
					strcat(pszRecursivePath, finddata.cFileName);
					MakeFullPath(pszRecursivePath);
					ProcessSinglePath(pszRecursivePath);
				}
				findResult = FindNextFile(findHandle, &finddata);
			}
			FindClose(findHandle);
		}
		else
			return E_FAIL;
	}
	else  	// non-recursive routine
	{
		MakeFullPath(pszPath);
		ProcessSinglePath(pszPath);
	}
	return S_OK;
}


void ScriptWriter::MakeFullPath(char* pszPath)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::MakeFullPath with char parameter %s\n",
//		pszPath);

	BOOL isMinLen = strlen(pszPath) > 1;
	BOOL isUNC = isMinLen && strncmp(pszPath, "\\\\", 2) == 0;

	if(isUNC) return;

	CHAR buf[MAX_PATH * 2];
	CHAR *pFileName;
	GetFullPathName(pszPath, MAX_PATH * 2, buf, &pFileName);
	ResolveLink(buf, pszPath);
//	LauncherLog::Log(Debug,
//		"[launcher] After call to ScriptWriter::ResolveLink(), path is %s\n",
//		pszPath);
}


/* Resolve a Shortcut (ShellLink)
 * Put the resolved path into outPath
 * Copies path to outPath on failure so
 * outPath is always a useable path
 */
HRESULT ScriptWriter::ResolveLink(char* path, char* outPath)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling ScriptWriter::ResolveLink() with char parameters: %s, %s\n",
//		path, outPath);

	IShellLink *psl;
	HRESULT hres;

	hres = CoCreateInstance(CLSID_ShellLink, NULL,
		CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *)&psl);
	if (SUCCEEDED(hres))
	{
		IPersistFile *ppf;
		hres = psl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
		if (SUCCEEDED(hres))
		{
			WORD wsz[MAX_PATH];
		    MultiByteToWideChar(CP_ACP, 0, path, -1, wsz, MAX_PATH);
		    hres = ppf->Load(wsz, STGM_READ);
			if (SUCCEEDED(hres))
			{
//				LauncherLog::Log(Debug, "[launcher] IPersistFile::Load call succeeded.\n");
				hres = psl->Resolve(0, SLR_ANY_MATCH | SLR_NO_UI);
				if (SUCCEEDED(hres))
				{
//					LauncherLog::Log(Debug,
//						"[launcher] IShellLink::Resolve call succeeded.\n");
					WIN32_FIND_DATA wfd;
					char szgotpath[MAX_PATH];
					ZeroMemory(szgotpath, MAX_PATH);
				    hres = psl->GetPath(szgotpath, MAX_PATH,
						&wfd, SLGP_SHORTPATH);
					if(SUCCEEDED(hres))
					{
//						LauncherLog::Log(Debug,
//							"[launcher] IShellLink::GetPath() call succeeded; resolved path is %s\n",
//							((szgotpath == 0 || strlen(szgotpath) == 0)
//								? "<zero-length string>." : szgotpath));
						if(szgotpath != 0 && strlen(szgotpath) != 0)
							strcpy(outPath, szgotpath);
					}
					else
					{
						LauncherLog::Log(Error,
							"[launcher] IShellLink::GetPath() call failed. Error code: 0x%08x\n",
							hres);
					}
				}
				else
				{
					LauncherLog::Log(Error,
						"[launcher] IShellLink::Resolve() call failed. Error code: 0x%08x\n",
						hres);
				}
			}
			else
			{
//				LauncherLog::Log(Debug,
//					"[launcher] IPersistFile::Load() call failed. Error code: 0x%08x\n",
//					hres);
			}
			ppf->Release();
		}
		else
		{
			LauncherLog::Log(Error,
				"[launcher] Could not get pointer to IPersistFile object. Error code: 0x%08x\n",
				hres);
		}
		psl->Release();
	}
	else
	{
		LauncherLog::Log(Error,
			"[launcher] Could not get pointer to IShellLink object. Error code: 0x%08x\n",
			hres);
	}
	if(!SUCCEEDED(hres))
	{
		strcpy(outPath, path);
	}
	return hres;
}


void ScriptWriter::AppendPath(const char* path)
{
	if(path == 0) return;
	const char* s = path;
	char *d = pBuffer + strlen(pBuffer);
	*d++ = '\"';
	while(*s != 0)
	{
		if(*s == '\\')
			*d++ = '\\';
		*d++ = *s++;
	}
	*d++ = '\"';
	*d = 0;
}


void ScriptWriter::Append(const char* source)
{
	strcat(pBuffer, source);
}


// Implementation of class OpenFileScript

OpenFileScript::OpenFileScript()
	: ScriptWriter(), m_nFiles(0)
{
	InitBuffer(0x2000);
}

OpenFileScript::~OpenFileScript() {}


HRESULT OpenFileScript::WritePrefix()
{
//	LauncherLog::Log(Debug,"[launcher] Calling OpenFileScript::WritePrefix()\n");
	ClearBuffer();
	Append("v = new java.util.Vector(8); ");
	return S_OK;
}


HRESULT OpenFileScript::ProcessSinglePath(const char* pszPath)
{
//	LauncherLog::Log(Debug,
//		"[launcher] Calling OpenFileScript::ProcessSinglePath() with char parameter %s\n",
//		pszPath);
	if(m_nFiles < 128)
	{
		Append("v.addElement(");
		AppendPath(pszPath);
		Append("); ");
		++m_nFiles;
	}
	return S_OK;
}


HRESULT OpenFileScript::WriteSuffix()
{
//	LauncherLog::Log(Debug,"[launcher] Calling OpenFileScript::WriteSuffix()\n");
	if(m_nFiles == 0)
	{
		ClearBuffer();
		Append("Macros.error(jEdit.getFirstView(), ");
		Append("\"No files met the supplied wild-card specification.\");");
	}
	else
	{
		Append("s = v.size(); args = new String[s]; v.copyInto(args); ");
		Append("EditServer.handleClient(true, null, args); ");
		Append("jEdit.openFile(jEdit.getLastView(), args[s - 1]);\n\n");
	}
	return S_OK;
}

// Implementation of class OpenDiffScript

/*
	Here is the script written by this object:
	It will work with jDiff version written for
	jEdit 3.2.2 and jEdit 4.0
 // ----- prefix -----
 	v = jEdit.getFirstView();
	jDiff40 = false;
	if(jEdit.getPlugin("JDiffPlugin") == null) {
		jDiff40 = true;
	}
	if(jEdit.getPlugin("jdiff.JDiffPlugin") == null) {
		Macros.error(v, "You must have the JDiff plugin "
        	+ "installed to use this jEditLauncher feature.");
			return;
	}
	if(jDiff40) {
		if(jdiff.DualDiff.isEnabledFor(v))
			jdiff.DualDiff.toggleFor(v);
	}
	else if(DualDiff.isEnabledFor(v))
		DualDiff.toggleFor(v);
	while(v.getEditPanes().length > 1)
		v.unsplit();
	v.splitVertically();
	if(jDiff40)
		jdiff.DualDiff.toggleFor(v);
	else
		DualDiff.toggleFor(v);
	openDiffFiles(vv) {
		v = vv;
		run() {
			buf1 =
 // ----- file 1 -----
				jEdit.openFile(v, "<file 1>");
			buf2 =
 // ----- file 2 -----
			jEdit.openFile(v, "<file 2>");
 // ----- suffix -----
			VFSManager.waitForRequests();
			editPanes = v.getEditPanes();
			editPanes[0].setBuffer(buf1);
			editPanes[1].setBuffer(buf2);
		}
		return this;
	}
	SwingUtilities.invokeLater(openDiffFiles(v));

*/

OpenDiffScript::OpenDiffScript()
	: ScriptWriter(), secondFile(false)
{
	InitBuffer(1024);
}

OpenDiffScript::~OpenDiffScript() {}

HRESULT OpenDiffScript::WritePrefix()
{
	ClearBuffer();
	Append("v = jEdit.getFirstView(); ");
	Append("jDiff40 = false;");
	Append("if(jEdit.getPlugin(\"JDiffPlugin\") == null) {jDiff40 = true;} ");
	Append("if(jEdit.getPlugin(\"jdiff.JDiffPlugin\") == null) { ");
	Append("Macros.error(v, \"You must have the JDiff plugin ");
	Append("installed to use this jEditLauncher feature.\"); return; } ");
	Append("if(jDiff40) { if(jdiff.DualDiff.isEnabledFor(v)) ");
	Append("jdiff.DualDiff.toggleFor(v); } ");
	Append("else if(DualDiff.isEnabledFor(v)) DualDiff.toggleFor(v); ");
	Append("while(v.getEditPanes().length > 1) v.unsplit(); ");
	Append("v.splitVertically(); ");
	Append("if(jDiff40) jdiff.DualDiff.toggleFor(v); else ");
	Append("DualDiff.toggleFor(v); openDiffFiles(vv) { v = vv; run() { buf1 = ");
	return S_OK;
}


HRESULT OpenDiffScript::ProcessSinglePath(const char* pszPath)
{
	Append("jEdit.openFile(v, ");
	AppendPath(pszPath);
	Append("); ");
	if(!secondFile)
	{
		Append("buf2 = ");
		secondFile = true;
	}
	return S_OK;
}


HRESULT OpenDiffScript::WriteSuffix()
{
	Append("VFSManager.waitForRequests(); editPanes = v.getEditPanes(); ");
	Append("editPanes[0].setBuffer(buf1); ");
	Append("editPanes[1].setBuffer(buf2); } return this; } ");
	Append("SwingUtilities.invokeLater(openDiffFiles(v));");
	return S_OK;
}


// Implementation of class StartAppScript

StartAppScript::StartAppScript(LPCTSTR lpszCmdLine)
	: ScriptWriter(), bFirstFile(true), m_lpszCmdLine(lpszCmdLine)
{
	InitBuffer(2048);
}

StartAppScript::~StartAppScript() {}

HRESULT StartAppScript::WritePrefix()
{
	ClearBuffer();
	Append(m_lpszCmdLine);
	return S_OK;
}



HRESULT StartAppScript::ProcessSinglePath(const char* pszPath)
{
	if(bFirstFile)
	{
		Append("-- ");
		bFirstFile = false;
	}
	AppendPath(pszPath);
	Append(" ");
	return S_OK;
}


HRESULT StartAppScript::WriteSuffix()
{
	bFirstFile = true;		// reset
	return S_OK;
}


// Implementation of class FileListScript

FileListScript::FileListScript()
	: ScriptWriter()
{
	InitBuffer(1024);
}

FileListScript::~FileListScript() {}

HRESULT FileListScript::WritePrefix()
{
	ClearBuffer();
	Append("-- ");
	return S_OK;
}


HRESULT FileListScript::ProcessSinglePath(const char* pszPath)
{
	AppendPath(pszPath);
	Append(" ");
	return S_OK;
}


HRESULT FileListScript::WriteSuffix()
{
	return S_OK;
}
