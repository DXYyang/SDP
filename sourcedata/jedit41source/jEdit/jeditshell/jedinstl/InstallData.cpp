/*
 * InstallData.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: InstallData.cpp,v 1.10 2002/02/19 03:33:44 jgellene Exp $
 */

#include "stdafx.h"
#include "StringPtr.h"
#include "InstallerLog.h"
#include "InstallData.h"

bool InstallData::Init()
{
	// NOTE: check OS
	char szWinVer[64];
	OSVERSIONINFO osver;
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osver);
	bIsWinNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);

	strcpy(szWinVer, "<no version detected>");
	switch(osver.dwMajorVersion)
	{
		case 5:
		{
			if(osver.dwMinorVersion == 0)
			{
				strcpy(szWinVer, "Windows 2000");
			}
			else
			{
				strcpy(szWinVer, "Windows XP");
			}
			break;

		}
		case 4:
		{
			if(osver.dwMinorVersion == 0)
			{
				strcpy(szWinVer, bIsWinNT ? "Windows NT 4.0" : "Windows 95");
			}
			else if(osver.dwMinorVersion == 10)
			{
				strcpy(szWinVer, "Windows 98");
			}
			else if(osver.dwMinorVersion == 90)
			{
				strcpy(szWinVer, "Windows ME");
			}
			break;
		}
		default:
		{
			strcpy(szWinVer, "Incompatible Windows version");
		}
	}
	InstallerLog::Log(Debug, "Operating system is %s\n", szWinVer);


	HKEY hKey = 0;

	// NOTE: find if 3.2 or 4.0 is already installed
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
		_T("Software\\www.jedit.org\\jEditLauncher\\3.2"), 0, KEY_READ, &hKey))
	{
		bIs32 = true;
	}
	RegCloseKey(hKey);
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
		_T("Software\\www.jedit.org\\jEditLauncher\\4.0"), 0, KEY_READ, &hKey))
	{
		bIs40 = true;
	}
	RegCloseKey(hKey);
	InstallerLog::Log(Debug, "Version 3.2 found %s, version 4.0 found %s\n",
		bIs32 ? "true" : "false", bIs40 ? "true" : "false");

	// NOTE: find current version of launcher module
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT,
		_T("JEdit.JEditLauncher\\CurVer"), 0, KEY_READ, &hKey))
	{
		TCHAR szVersion[64];
		DWORD bufSize = 64;
		RegQueryValueEx(hKey, 0, 0, 0, (unsigned char*)szVersion, &bufSize);
		if(lstrcmp(szVersion, "JEdit.JEditLauncher.3.2") == 0)
		{
			bIsCurrent32 = true;
		}
		else if(lstrcmp(szVersion, "JEdit.JEditLauncher.4.0") == 0)
		{
			bIsCurrent40 = true;
		}
	}
	RegCloseKey(hKey);

	InstallerLog::Log(Debug, "Currently installed: version %s\n",
		(bIsCurrent32 ? "version 3.2" :
			(bIsCurrent40 ? "version 4.0" : "no version")));


	// NOTE: find location of context menu handler
	CString strCtxMenuGUID, strCtxMenuPath;
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT,
		_T("*\\shellex\\ContextMenuHandlers\\Open with jEdit"),
		0, KEY_READ, &hKey))
	{
		CStringBuf<> pBuf(strCtxMenuGUID);
		DWORD bufSize = pBuf.Size();
		RegQueryValueEx(hKey, 0, 0, 0, pBuf, &bufSize);
	}
	RegCloseKey(hKey);
//	InstallerLog::Log(Debug, "strCtxMenuGUID = %s\n", strCtxMenuGUID);
	if(strCtxMenuGUID.GetLength() != 0)
	{
		strCtxMenuPath = CString("CLSID\\");
		strCtxMenuPath += strCtxMenuGUID;
		strCtxMenuPath += _T("\\InprocServer32");
//		InstallerLog::Log(Debug, "strCtxMenuPath = %s\n", strCtxMenuPath);
		if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT,
			strCtxMenuPath,	0, KEY_READ, &hKey))
		{
			InstallerLog::Log(Debug, "Context menu handler is installed.\n");
			bIsCtxMenuInstalled = true;
			CStringBuf<> pBuf(strCtxMenuPath);
			DWORD bufSize = pBuf.Size();
			RegQueryValueEx(hKey, 0, 0, 0, pBuf, &bufSize);
		}
		RegCloseKey(hKey);
	}

	/*
	 * we must confirm we have the correct version of the component available
	 * we look in the following places
	 * 		1.	a new installation should have "jeshlstb.dl_" in the
	 * 			current directory
	 * 		2.	if not present, then check for "jeshlstb.dll" in the current
	 * 			directory
	 * if no file is available, installation fails
	 * if succeeds, set strFullInstallName to correct full name (after renaming)
	 */
//	InstallerLog::Log(Debug, "Install directory is %s\n", strInstallDir);
//	InstallerLog::Log(Debug, "'Install name' is %s\n", strInstallName);
 	CString strComponentPath(strInstallDir), strInstallPath("");
	strComponentPath += _T('\\');
	strComponentPath += strInstallName;
	InstallerLog::Log(Debug, "Searching for %s\n", strComponentPath);
	if(GetFileAttributes(strComponentPath) != -1)
	{
		InstallerLog::Log(Debug, "Found %s\n", strComponentPath);
		strInstallPath = strComponentPath;
	}
	else
	{
		strComponentPath.SetAt(strComponentPath.GetLength() - 1, _T('l'));
		InstallerLog::Log(Debug, "Searching for %s\n", strComponentPath);
		if(GetFileAttributes(strComponentPath) != -1)
		{
			InstallerLog::Log(Debug, "Found %s\n", strComponentPath);
			strInstallPath = strComponentPath;
		}
		else
		{
			InstallerLog::Log(Error, "Could not find context menu module.\n");
			return false;
		}
	}
//	InstallerLog::Log(Debug, "strCtxMenuPath = %s\n", strCtxMenuPath);
	// NOTE: Compare ctx menu directory with current install directory
	if(strCtxMenuPath.GetLength() != 0)
	{
		CStringBuf<> pCurrBuf(strCtxMenuPath);
		ShortenToDirectory(pCurrBuf);
		GetShortPathName(pCurrBuf, pCurrBuf, pCurrBuf.Size());
		CString strShortInstallDir(strInstallDir);
		CStringBuf<> pInstallBuf(strShortInstallDir);
		GetShortPathName(pInstallBuf, pInstallBuf, pInstallBuf.Size());
		if(lstrcmpi(pCurrBuf, pInstallBuf) == 0)
		{
			bInstallCtxMenu = false;
		}
	}

	strInstallFinalPath = strInstallPath;
	strInstallFinalPath.SetAt(strInstallFinalPath.GetLength() - 1, _T('l'));
	if(strInstallPath.Compare(strInstallFinalPath) == 0)
		bUsingTempFileName = false;
	InstallerLog::Log(Debug, "Using %s for name of context menu handler.\n",
		bUsingTempFileName ? "jeshlstb.dl_" : "jeshlstb.dll");
	return true;
}

void InstallData::ShortenToDirectory(TCHAR* lpszPath)
{
	TCHAR* pSlash = 0;
	TCHAR* p = lpszPath;
	while (*p != 0)
	{
		if (*p == _T('\\'))
			pSlash = p;
		p = ::CharNext(p);
	}
	if(pSlash == 0)
		*(lpszPath + 2) = 0; // drive name only
	else
		*pSlash = 0;
}

DWORD InstallData::GetBufferByteLen(const WTL::CString& str)
{
	return (str.GetLength() + 1) * sizeof(TCHAR);
}

#if defined(_DEBUG)

void InstallData::Dump()
{
	OutputDebugString("Dumping InstallData....\n");
	CString strOutput;
	strOutput.Format("strJavaHome: %s\nstrInstallDir: %s\nstrInstallName: %s\n",
		strJavaHome, strInstallDir, strInstallName);
	OutputDebugString(strOutput);
	strOutput.Format("strOldPath: %s\nstrInstallGUID: %s\nstrInstallVersion: %s\n",
		strOldPath, strInstallGUID, strInstallVersion);
	OutputDebugString(strOutput);
	strOutput.Format("strApp: %s\nstrVersionLabel: %s\n",
		strApp, strVersionLabel);
	OutputDebugString(strOutput);
	strOutput.Format("bRebootRequired: %s\nbUsingTempFileName: %s\nbIsWinNT: %s\n",
		bRebootRequired ? "true" : "false", bUsingTempFileName ? "true" : "false",
		bIsWinNT ? "true" : "false");
	OutputDebugString(strOutput);
	strOutput.Format("dwInstalledVersion: %d\nnInstalledVersions: %d\nnIndexSubjectVer: %d\n",
		dwInstalledVersions, nInstalledVersions, nIndexSubjectVer);
	OutputDebugString(strOutput);
	strOutput.Format("nIndexOverwrittenVer: %d\nnIndexCurrentVer: %d\n",
		nIndexOverwrittenVer, nIndexCurrentVer);
	OutputDebugString(strOutput);
	strOutput.Format("arPathNames:\n");
	OutputDebugString(strOutput);
	unsigned int n;
	for(n = 0; n < nInstalledVersions; ++n)
	{
		strOutput.Format("    Item %d: %s\n", n, arPathNames[n]);
		OutputDebugString(strOutput);
	}
	strOutput.Format("arVersionNames:\n");
	OutputDebugString(strOutput);
	for(n = 0; n < nInstalledVersions; ++n)
	{
		strOutput.Format("    Item %d: %s\n", n, arVersionNames[n]);
		OutputDebugString(strOutput);
	}
}

#endif
